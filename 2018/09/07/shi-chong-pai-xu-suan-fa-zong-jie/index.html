<!DOCTYPE HTML>
<html lang="">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="十种排序算法总结, 胡佳艺">
    <meta name="description" content="1.冒泡排序算法思想：从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，每一轮循环下来找出剩余未排序数的中的最大数并”冒泡”至数列的顶端。
算法步骤：（1）从数组中第一个数开始，依次与下一个数比较并次交换比自己小的数，直到最">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>十种排序算法总结 | 胡佳艺</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">胡佳艺</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于我</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友链</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="Search"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">胡佳艺</div>
        <div class="logo-desc">
            
            这是一个半吊子的博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于我
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友链
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/darenzai/" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/darenzai/" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/images/首页24.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        十种排序算法总结
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="container content">

    
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/数据结构/" target="_blank">
                                <span class="chip bg-color">数据结构</span>
                            </a>
                        
                            <a href="/tags/排序/" target="_blank">
                                <span class="chip bg-color">排序</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/数据结构/" class="post-category" target="_blank">
                                数据结构
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2018-09-07
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>Word Count:&nbsp;&nbsp;
                        6.1k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>Read Times:&nbsp;&nbsp;
                        23 Min
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><p>从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，每一轮循环下来找出剩余未排序数的中的最大数并”冒泡”至数列的顶端。</p>
<h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h3><p>（1）从数组中第一个数开始，依次与下一个数比较并次交换比自己小的数，直到最后一个数。如果发生交换，则继续下面的步骤，如果未发生交换，则数组有序，排序结束，此时时间复杂度为O(n)；<br>（2）每一轮”冒泡”结束后，最大的数将出现在乱序数列的最后一位。重复步骤（1）。</p>
<p>稳定性：稳定排序。</p>
<p>时间复杂度： O(n)至，平均时间复杂度为。</p>
<p>最好的情况：如果待排序数据序列为正序，则一趟冒泡就可完成排序，排序码的比较次数为n-1次，且没有移动，时间复杂度为O(n)。</p>
<p>最坏的情况：如果待排序数据序列为逆序，则冒泡排序需要n-1次趟起泡，每趟进行n-i次排序码的比较和移动，即比较和移动次数均达到最大值：<br>比较次数:<br>移动次数等于比较次数，因此最坏时间复杂度为。</p>
<p>示例代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//循环的次数为数组长度减一，剩下的一个数不需要排序</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
        bool noswap<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//循环次数为待排序数第一位数冒泡至最高位的比较次数</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//交换或者使用如下方式</span>
                <span class="token comment" spellcheck="true">//a=a^b;</span>
                <span class="token comment" spellcheck="true">//b=b^a;</span>
                <span class="token comment" spellcheck="true">//a=a^b;</span>
                noswap<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>noswap<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>1
2<br>3
4<br>5
6<br>7
8<br>9
10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20</p>
<h3 id="2-1-2快速排序"><a href="#2-1-2快速排序" class="headerlink" title="2.1.2快速排序"></a>2.1.2快速排序</h3><p>冒泡排序是在相邻的两个记录进行比较和交换，每次交换只能上移或下移一个位置，导致总的比较与移动次数较多。快速排序又称分区交换排序，是对冒泡排序的改进，快速排序采用的思想是分治思想。。</p>
<p>算法原理：<br>(1)从待排序的n个记录中任意选取一个记录（通常选取第一个记录）为分区标准;</p>
<p>(2)把所有小于该排序列的记录移动到左边，把所有大于该排序码的记录移动到右边，中间放所选记录，称之为第一趟排序；</p>
<p>(3)然后对前后两个子序列分别重复上述过程，直到所有记录都排好序。</p>
<p>稳定性：不稳定排序。</p>
<p>时间复杂度： 至，平均时间复杂度为。</p>
<p>最好的情况：是每趟排序结束后，每次划分使两个子文件的长度大致相等，时间复杂度为。</p>
<p>最坏的情况：是待排序记录已经排好序，第一趟经过n-1次比较后第一个记录保持位置不变，并得到一个n-1个元素的子记录；第二趟经过n-2次比较，将第二个记录定位在原来的位置上，并得到一个包括n-2个记录的子文件，依次类推，这样总的比较次数是：<br>示例代码：</p>
<p>//a：待排序数组，low：最低位的下标，high：最高位的下标</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">>=</span>high<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> left<span class="token operator">=</span>low<span class="token punctuation">;</span>
    <span class="token keyword">int</span> right<span class="token operator">=</span>high<span class="token punctuation">;</span>
    <span class="token keyword">int</span> key<span class="token operator">=</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*用数组的第一个记录作为分区元素*/</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">!=</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">>=</span>key<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/*从右向左扫描，找第一个码值小于key的记录，并交换到key*/</span>
            <span class="token operator">--</span>right<span class="token punctuation">;</span>
        a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;=</span>key<span class="token punctuation">)</span>
            <span class="token operator">++</span>left<span class="token punctuation">;</span>
        a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*从左向右扫描，找第一个码值大于key的记录，并交换到右边*/</span>
    <span class="token punctuation">}</span>
    a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>key<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*分区元素放到正确位置*/</span>
    <span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>low<span class="token punctuation">,</span>left<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>1
2<br>3
4<br>5
6<br>7
8<br>9
10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>2.2插入类排序</p>
<p>1
2<br>3
4<br>5
6<br>7
8<br>9
10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>2.2插入类排序</p>
<p>插入排序的基本方法是：每步将一个待排序的记录，按其排序码大小，插到前面已经排序的文件中的适当位置，直到全部插入完为止。</p>
<h3 id="2-2-1直接插入排序"><a href="#2-2-1直接插入排序" class="headerlink" title="2.2.1直接插入排序"></a>2.2.1直接插入排序</h3><p>原理：从待排序的n个记录中的第二个记录开始，依次与前面的记录比较并寻找插入的位置，每次外循环结束后，将当前的数插入到合适的位置。</p>
<p>稳定性：稳定排序。</p>
<p>时间复杂度： O(n)至，平均时间复杂度是。</p>
<p>最好情况：当待排序记录已经有序，这时需要比较的次数是。</p>
<p>最坏情况：如果待排序记录为逆序，则最多的比较次数为。</p>
<p>示例代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//A：输入数组，len:数组长度</span>
<span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
      temp<span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> 
      <span class="token comment" spellcheck="true">//查找到要插入的位置</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>temp<span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
          A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
          j<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">!=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>1
2<br>3
4<br>5
6<br>7
8<br>9
10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>2.2.2 Shell排序</p>
<p>Shell 排序又称缩小增量排序, 由D. L. Shell在1959年提出，是对直接插入排序的改进。</p>
<p>原理： Shell排序法是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。</p>
<p>Shell排序开始时增量较大，分组较多，每组的记录数目较少，故在各组内采用直接插入排序较快，后来增量逐渐缩小，分组数减少，各组的记录数增多，但由于已经按分组排序，文件叫接近于有序状态，所以新的一趟排序过程较快。因此Shell排序在效率上比直接插入排序有较大的改进。</p>
<p>在直接插入排序的基础上，将直接插入排序中的1全部改变成增量d即可，因为Shell排序最后一轮的增量d就为1。</p>
<p>稳定性：不稳定排序。</p>
<p>时间复杂度：到。Shell排序算法的时间复杂度分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。研究证明，若增量的取值比较合理，Shell排序算法的时间复杂度约为。</p>
<p>对于增量的选择，Shell 最初建议增量选择为n/2，并且对增量取半直到 1；D. Knuth教授建议序列。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//A：输入数组，len:数组长度，d:初始增量(分组数)</span>
<span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> inc<span class="token operator">=</span>d<span class="token punctuation">;</span>inc<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>inc<span class="token operator">/=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//循环的次数为增量缩小至1的次数</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>inc<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//循环的次数为第一个分组的第二个元素到数组的结束</span>
            <span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span>inc<span class="token punctuation">;</span>
            <span class="token keyword">int</span> temp<span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>temp<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                A<span class="token punctuation">[</span>j<span class="token operator">+</span>inc<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                j<span class="token operator">=</span>j<span class="token operator">-</span>inc<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>j<span class="token operator">+</span>inc<span class="token punctuation">)</span><span class="token operator">!=</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//防止自我插入</span>
                A<span class="token punctuation">[</span>j<span class="token operator">+</span>inc<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//插入记录</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>1
2<br>3
4<br>5
6<br>7
8<br>9
10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>注意：从代码中可以看出，增量每次变化取前一次增量的一般，当增量d等于1时，shell排序就退化成了直接插入排序了。</p>
<h3 id="2-3选择类排序"><a href="#2-3选择类排序" class="headerlink" title="2.3选择类排序"></a>2.3选择类排序</h3><p>选择类排序的基本方法是：每步从待排序记录中选出排序码最小的记录，顺序放在已排序的记录序列的后面，知道全部排完。</p>
<h3 id="2-3-1简单选择排序（又称直接选择排序）"><a href="#2-3-1简单选择排序（又称直接选择排序）" class="headerlink" title="2.3.1简单选择排序（又称直接选择排序）"></a>2.3.1简单选择排序（又称直接选择排序）</h3><p>原理：从所有记录中选出最小的一个数据元素与第一个位置的记录交换；然后在剩下的记录当中再找最小的与第二个位置的记录交换，循环到只剩下最后一个数据元素为止。</p>
<p>稳定性：不稳定排序。</p>
<p>时间复杂度： 最坏、最好和平均复杂度均为，因此，简单选择排序也是常见排序算法中性能最差的排序算法。简单选择排序的比较次数与文件的初始状态没有关系，在第i趟排序中选出最小排序码的记录，需要做n-i次比较，因此总的比较次数是：。</p>
<p>示例代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       k<span class="token operator">=</span>i<span class="token punctuation">;</span>
       <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
               k<span class="token operator">=</span>j<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>
           A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
           A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
           A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>1
2<br>3
4<br>5
6<br>7
8<br>9
10<br>11<br>12<br>13<br>14<br>15<br>16<br>2.3.2堆排序</p>
<p>直接选择排序中，第一次选择经过了n-1次比较，只是从排序码序列中选出了一个最小的排序码，而没有保存其他中间比较结果。所以后一趟排序时又要重复许多比较操作，降低了效率。J. Willioms和Floyd在1964年提出了堆排序方法，避免这一缺点。</p>
<p>堆的性质：<br>（1）性质：完全二叉树或者是近似完全二叉树；<br>（2）分类：大顶堆：父节点不小于子节点键值，小顶堆：父节点不大于子节点键值；图展示一个最小堆：<br>这里写图片描述</p>
<p>（3）左右孩子：没有大小的顺序。</p>
<h3 id="（4）堆的存储"><a href="#（4）堆的存储" class="headerlink" title="（4）堆的存储"></a>（4）堆的存储</h3><p>一般都用数组来存储堆，i结点的父结点下标就为。它的左右子结点下标分别为  和 。如第0个结点左右子结点下标分别为1和2。<br>这里写图片描述</p>
<h3 id="（5）堆的操作"><a href="#（5）堆的操作" class="headerlink" title="（5）堆的操作"></a>（5）堆的操作</h3><p>建立：<br>以最小堆为例，如果以数组存储元素时，一个数组具有对应的树表示形式，但树并不满足堆的条件，需要重新排列元素，可以建立“堆化”的树。</p>
<p>这里写图片描述</p>
<p>插入：<br>将一个新元素插入到表尾，即数组末尾时，如果新构成的二叉树不满足堆的性质，需要重新排列元素，下图演示了插入15时，堆的调整。</p>
<p>这里写图片描述</p>
<p>删除：<br>堆排序中，删除一个元素总是发生在堆顶，因为堆顶的元素是最小的（小顶堆中）。表中最后一个元素用来填补空缺位置，结果树被更新以满足堆条件。</p>
<p>这里写图片描述</p>
<p>稳定性：不稳定排序。</p>
<p>插入代码实现：<br>每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中，这就类似于直接插入排序中将一个数据并入到有序区间中，这是节点“上浮”调整。不难写出插入一个新数据时堆的调整代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//新加入i结点,其父结点为(i-1)/2</span>
<span class="token comment" spellcheck="true">//参数：a：数组，i：新插入元素在数组中的下标  </span>
<span class="token keyword">void</span> <span class="token function">minHeapFixUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">int</span> j<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>  
    temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    j <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//父结点  </span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temp<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果父节点不大于新插入的元素，停止寻找  </span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>  
        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//把较大的子结点往下移动,替换它的子结点  </span>
        i <span class="token operator">=</span> j<span class="token punctuation">;</span>  
        j <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  </code></pre>
<p>1
2<br>3
4<br>5
6<br>7
8<br>9
10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>因此，插入数据到最小堆时：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//在最小堆中加入新的数据data  </span>
<span class="token comment" spellcheck="true">//a：数组，index：插入的下标，</span>
<span class="token keyword">void</span> <span class="token function">minHeapAddNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    a<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>  
    <span class="token function">minHeapFixUp</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span> </code></pre>
<p>1
2<br>3
4<br>5
6<br>7
删除代码实现：<br>按定义，堆中每次都只能删除第0个数据。为了便于重建堆，实际的操作是将数组最后一个数据与根结点，然后再从根结点开始进行一次从上向下的调整。</p>
<p>调整时先在左右儿子结点中找最小的，如果父结点不大于这个最小的子结点说明不需要调整了，反之将最小的子节点换到父结点的位置。此时父节点实际上并不需要换到最小子节点的位置，因为这不是父节点的最终位置。但逻辑上父节点替换了最小的子节点，然后再考虑父节点对后面的结点的影响。相当于从根结点将一个数据的“下沉”过程。下面给出代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//a为数组，从index节点开始调整,len为节点总数 从0开始计算index节点的子节点为 2*index+1, 2*index+2,len/2-1为最后一个非叶子节点  </span>
<span class="token keyword">void</span> <span class="token function">minHeapFixDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">></span><span class="token punctuation">(</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//index为叶子节点不用调整</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> tmp<span class="token operator">=</span>a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> lastIndex<span class="token operator">=</span>index<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">&lt;=</span><span class="token punctuation">(</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//当下沉到叶子节点时，就不用调整了</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>tmp<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果左子节点大于该节点</span>
            lastIndex <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//如果存在右子节点且大于左子节点和该节点</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">2</span><span class="token operator">&lt;</span>len <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>tmp<span class="token punctuation">)</span>
            lastIndex <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>lastIndex<span class="token operator">!=</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//如果左右子节点有一个小于该节点则设置该节点的下沉位置</span>
            a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
            index<span class="token operator">=</span>lastIndex<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//否则该节点不用下沉调整</span>
    <span class="token punctuation">}</span>
    a<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将该节点放到最后的位置</span>
<span class="token punctuation">}</span></code></pre>
<p>1
2<br>3
4<br>5
6<br>7
8<br>9
10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>根据思想，可以有不同版本的代码实现，以上是和孙凛同学一起讨论出的一个版本，在这里感谢他的参与，读者可另行给出。个人体会，这里建议大家根据对堆调整的过程的理解，写出自己的代码，切勿看示例代码去理解算法，而是理解算法思想写出代码，否则很快就会忘记。</p>
<p>建堆：<br>有了堆的插入和删除后，再考虑下如何对一个数据进行堆化操作。要一个一个的从数组中取出数据来建立堆吧，不用！先看一个数组，如下图：</p>
<p>这里写图片描述</p>
<p>很明显，对叶子结点来说，可以认为它已经是一个合法的堆了即20，60， 65， 4， 49都分别是一个合法的堆。只要从A[4]=50开始向下调整就可以了。然后再取A[3]=30，A[2] = 17，A[1] = 12，A[0] = 9分别作一次向下调整操作就可以了。下图展示了这些步骤：</p>
<p>这里写图片描述</p>
<p>写出堆化数组的代码：</p>
<p>//建立最小堆</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//a:数组，n：数组长度</span>
<span class="token keyword">void</span> <span class="token function">makeMinHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>  
        <span class="token function">minHeapFixDown</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  </code></pre>
<p>1
2<br>3
4<br>5
6<br>7</p>
<p>1
2<br>3
4<br>5
6<br>7</p>
<h3 id="（6）堆排序的实现"><a href="#（6）堆排序的实现" class="headerlink" title="（6）堆排序的实现"></a>（6）堆排序的实现</h3><p>由于堆也是用数组来存储的，故对数组进行堆化后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n – 2]交换，再对A[0…n - 3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。有点类似于直接选择排序。</p>
<p>因此，完成堆排序并没有用到前面说明的插入操作，只用到了建堆和节点向下调整的操作，堆排序的操作如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//array:待排序数组，len：数组长度</span>
<span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//建堆</span>
    <span class="token function">makeMinHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment" spellcheck="true">//根节点和最后一个叶子节点交换，并进行堆调整，交换的次数为len-1次</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//根节点和最后一个叶子节点交换</span>
        array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> array<span class="token punctuation">[</span>len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
        array<span class="token punctuation">[</span>len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>array<span class="token punctuation">[</span>len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
        array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>array<span class="token punctuation">[</span>len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

```
    <span class="token comment" spellcheck="true">//堆调整</span>
    <span class="token function">minHeapFixDown</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
```

<span class="token punctuation">}</span>  </code></pre>
<p>1
2<br>3
4<br>5
6<br>7
8<br>9
10<br>11<br>12<br>13<br>14<br>15</p>
<h3 id="（7）堆排序的性能分析"><a href="#（7）堆排序的性能分析" class="headerlink" title="（7）堆排序的性能分析"></a>（7）堆排序的性能分析</h3><p>由于每次重新恢复堆的时间复杂度为O(logN)，共N - 1次堆调整操作，再加上前面建立堆时N / 2次向下调整，每次调整时间复杂度也为O(logN)。两次次操作时间相加还是O(N * logN)。故堆排序的时间复杂度为O(N * logN)。</p>
<p>最坏情况：如果待排序数组是有序的，仍然需要O(N * logN)复杂度的比较操作，只是少了移动的操作；</p>
<p>最好情况：如果待排序数组是逆序的，不仅需要O(N * logN)复杂度的比较操作，而且需要O(N * logN)复杂度的交换操作。总的时间复杂度还是O(N * logN)。</p>
<p>因此，堆排序和快速排序在效率上是差不多的，但是堆排序一般优于快速排序的重要一点是，数据的初始分布情况对堆排序的效率没有大的影响。</p>
<h3 id="2-4归并排序"><a href="#2-4归并排序" class="headerlink" title="2.4归并排序"></a>2.4归并排序</h3><p>算法思想：<br>归并排序属于比较类非线性时间排序，号称比较类排序中性能最佳者，在数据中应用中较广。</p>
<p>归并排序是分治法（Divide and Conquer）的一个典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<p>稳定性：稳定排序算法；</p>
<p>时间复杂度: 最坏，最好和平均时间复杂度都是Θ(nlgn)。</p>
<p>具体的实现见本人的另一篇blog：二路归并排序简介及其并行化。</p>
<h3 id="2-5线性时间非比较类排序"><a href="#2-5线性时间非比较类排序" class="headerlink" title="2.5线性时间非比较类排序"></a>2.5线性时间非比较类排序</h3><h3 id="2-5-1计数排序"><a href="#2-5-1计数排序" class="headerlink" title="2.5.1计数排序"></a>2.5.1计数排序</h3><p>计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出，它的优势在于在对于较小范围内的整数排序。它的复杂度为Ο(n+k)（其中k是待排序数的范围），快于任何比较排序算法，缺点就是非常消耗空间。很明显，如果而且当O(k)&gt;O(n*log(n))的时候其效率反而不如基于比较的排序，比如堆排序和归并排序和快速排序。</p>
<p>算法原理：<br>基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，在代码中作适当的修改即可。</p>
<p>算法步骤：<br>（1）找出待排序的数组中最大的元素；<br>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p>
<p>时间复杂度：Ο(n+k)。</p>
<p>空间复杂度：Ο(k)。</p>
<p>要求：待排序数中最大数值不能太大。</p>
<p>稳定性：稳定。</p>
<p>代码示例：</p>
<pre class=" language-java"><code class="language-java">#define MAXNUM <span class="token number">20</span>    <span class="token comment" spellcheck="true">//待排序数的最大个数</span>
#define MAX    <span class="token number">100</span>   <span class="token comment" spellcheck="true">//待排序数的最大值</span>
<span class="token keyword">int</span> sorted_arr<span class="token punctuation">[</span>MAXNUM<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//计算排序</span>
<span class="token comment" spellcheck="true">//arr:待排序数组，sorted_arr：排好序的数组，n：待排序数组长度</span>
<span class="token keyword">void</span> <span class="token function">countSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>sorted_arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>  
<span class="token punctuation">{</span>   
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>   
    <span class="token keyword">int</span> <span class="token operator">*</span>count_arr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>MAX<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//初始化计数数组   </span>
<span class="token function">memset</span><span class="token punctuation">(</span>count_arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>MAX<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//统计i的次数   </span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  
    count_arr<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>  
<span class="token comment" spellcheck="true">//对所有的计数累加，作用是统计arr数组值和小于小于arr数组值出现的个数</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  
    count_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count_arr<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   
<span class="token comment" spellcheck="true">//逆向遍历源数组（保证稳定性），根据计数数组中对应的值填充到新的数组中   </span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>  
<span class="token punctuation">{</span>  
    <span class="token comment" spellcheck="true">//count_arr[arr[i]]表示arr数组中包括arr[i]和小于arr[i]的总数</span>
    sorted_arr<span class="token punctuation">[</span>count_arr<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  

    <span class="token comment" spellcheck="true">//如果arr数组中有相同的数，arr[i]的下标减一</span>
    count_arr<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span>
<span class="token function">free</span><span class="token punctuation">(</span>count_arr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>}
1<br>2
3<br>4
5<br>6
7<br>8
9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>注意：计数排序是典型的以空间换时间的排序算法，对待排序的数据有严格的要求，比如待排序的数值中包含负数，最大值都有限制，请谨慎使用。</p>
<h3 id="2-5-2基数排序"><a href="#2-5-2基数排序" class="headerlink" title="2.5.2基数排序"></a>2.5.2基数排序</h3><p>基数排序属于“分配式排序”（distribution sort），是非比较类线性时间排序的一种，又称“桶子法”（bucket sort）。顾名思义，它是透过键值的部分信息，将要排序的元素分配至某些“桶”中，藉以达到排序的作用。</p>
<p>具体描述即代码示例见本人另一篇blog:基数排序简介及其并行化。</p>
<h3 id="2-5-3桶排序"><a href="#2-5-3桶排序" class="headerlink" title="2.5.3桶排序"></a>2.5.3桶排序</h3><p>桶排序也是分配排序的一种，但其是基于比较排序的，这也是与基数排序最大的区别所在。</p>
<p>思想：桶排序算法想法类似于散列表。首先要假设待排序的元素输入符合某种均匀分布，例如数据均匀分布在[ 0,1）区间上，则可将此区间划分为10个小区间，称为桶，对散布到同一个桶中的元素再排序。</p>
<p>要求：待排序数长度一致。</p>
<p>排序过程：<br>（1）设置一个定量的数组当作空桶子；<br>（2）寻访序列，并且把记录一个一个放到对应的桶子去；<br>（3）对每个不是空的桶子进行排序。<br>（4）从不是空的桶子里把项目再放回原来的序列中。</p>
<p>例如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序。</p>
<p>时间复杂度：<br>对N个关键字进行桶排序的时间复杂度分为两个部分：<br>(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。</p>
<p>(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，对于N个待排数据，M个桶，平均每个桶[N/M]个数据，则桶内排序的时间复杂度为  。其中 为第i个桶的数据量。</p>
<p>因此，平均时间复杂度为线性的O(N+C)，C为桶内排序所花费的时间。当每个桶只有一个数，则最好的时间复杂度为：O(N)。</p>
<p>示例代码：</p>
<pre class=" language-java"><code class="language-java">typedef struct node
 <span class="token punctuation">{</span> 
     <span class="token keyword">int</span> keyNum<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//桶中数的数量</span>
     <span class="token keyword">int</span> key<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//存储的元素</span>
     struct node <span class="token operator">*</span> next<span class="token punctuation">;</span>  
 <span class="token punctuation">}</span>KeyNode<span class="token punctuation">;</span>    

 <span class="token comment" spellcheck="true">//keys待排序数组，size数组长度，bucket_size桶的数量</span>
 <span class="token keyword">void</span> <span class="token function">inc_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> keys<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">,</span><span class="token keyword">int</span> bucket_size<span class="token punctuation">)</span>
 <span class="token punctuation">{</span> 
     KeyNode<span class="token operator">*</span> k<span class="token operator">=</span><span class="token punctuation">(</span>KeyNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span>KeyNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于控制打印</span>
     <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>b<span class="token punctuation">;</span>
     KeyNode <span class="token operator">*</span><span class="token operator">*</span>bucket_table<span class="token operator">=</span><span class="token punctuation">(</span>KeyNode <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>bucket_size<span class="token operator">*</span><span class="token function">sizeof</span><span class="token punctuation">(</span>KeyNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
     <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>bucket_size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>  
         bucket_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>KeyNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span>KeyNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
         bucket_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span>keyNum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录当前桶中是否有数据</span>
         bucket_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//记录当前桶中的数据  </span>
         bucket_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>NULL<span class="token punctuation">;</span> 
     <span class="token punctuation">}</span>    </code></pre>
<pre class=" language-java"><code class="language-java"> <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>   
     <span class="token keyword">int</span> index<span class="token punctuation">;</span>
     KeyNode <span class="token operator">*</span>p<span class="token punctuation">;</span>
     KeyNode <span class="token operator">*</span>node<span class="token operator">=</span><span class="token punctuation">(</span>KeyNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span>KeyNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
     node<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">=</span>keys<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  
     node<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>NULL<span class="token punctuation">;</span>  

     index<span class="token operator">=</span>keys<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//映射函数计算桶号  </span>
     p<span class="token operator">=</span>bucket_table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//初始化P成为桶中数据链表的头指针  </span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>keyNum<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//该桶中还没有数据 </span>
     <span class="token punctuation">{</span>    
         bucket_table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>node<span class="token punctuation">;</span>    
         <span class="token punctuation">(</span>bucket_table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span>keyNum<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//桶的头结点记录桶内元素各数，此处加一</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">else</span><span class="token comment" spellcheck="true">//该桶中已有数据 </span>
     <span class="token punctuation">{</span>   
         <span class="token comment" spellcheck="true">//链表结构的插入排序 </span>
         <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">!=</span>NULL<span class="token operator">&amp;&amp;</span>p<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">&lt;=</span>node<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>   
             p<span class="token operator">=</span>p<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>    
         node<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>p<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>     
         p<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>node<span class="token punctuation">;</span>      
         <span class="token punctuation">(</span>bucket_table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span>keyNum<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>   
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 <span class="token comment" spellcheck="true">//打印结果</span>
 <span class="token keyword">for</span><span class="token punctuation">(</span>b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>b<span class="token operator">&lt;</span>bucket_size<span class="token punctuation">;</span>b<span class="token operator">++</span><span class="token punctuation">)</span>   
     <span class="token comment" spellcheck="true">//判断条件是跳过桶的头结点，桶的下个节点为元素节点不为空</span>
     <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span>bucket_table<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>k<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">!=</span>NULL<span class="token punctuation">;</span>k<span class="token operator">=</span>k<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span>  
     <span class="token punctuation">{</span>
         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>k<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span></code></pre>
<p> }</p>

            </div>
            <hr/>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone, qq, weibo, douban"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>Reprint policy</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《十种排序算法总结》
                </span> by
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2018/09/07/shi-chong-pai-xu-suan-fa-zong-jie/" property="cc:attributionName"
               rel="cc:attributionURL">
                胡佳艺
            </a> is licensed under a
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
                Creative Commons Attribution 4.0 International License
            </a> 
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'rI3qUXWMSbbh0LDGTPkuqfxF-gzGzoHsz',
        appKey: 'hwoKBUPcpPpjHvAiIbJRog7C',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'en',
        placeholder: 'just go go'
    });
</script>
    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2018/10/11/shou-ba-shou-jiao-ni-da-jian-ssm-xiang-mu/">
                    <div class="card-image">
                        
                        <img src="/images/首页27.jpg" class="responsive-img" alt="手把手教你搭建SSM项目">
                        
                        <span class="card-title">手把手教你搭建SSM项目</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Eclipse搭建SSM项目的基本步骤。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2018-10-11
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Spring/" class="post-category" target="_blank">
                                    Spring
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/SSM/" target="_blank">
                        <span class="chip bg-color">SSM</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2018/09/07/servlet-huo-qu-jsp-biao-dan-nei-rong/">
                    <div class="card-image">
                        
                        <img src="/images/首页20.jpg" class="responsive-img" alt="Servlet获取JSP表单内容">
                        
                        <span class="card-title">Servlet获取JSP表单内容</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            用Servlet获取Jsp表单里面的内容，然后打印出来。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2018-09-07
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JavaWeb/" class="post-category" target="_blank">
                                    JavaWeb
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JSP/" target="_blank">
                        <span class="chip bg-color">JSP</span>
                    </a>
                    
                    <a href="/tags/Servlet/" target="_blank">
                        <span class="chip bg-color">Servlet</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + 'From: 胡佳艺<br />'
            + 'Author: Darenzai<br />'
            + 'Link: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">39.3k</span>
            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/darenzai/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:1453566224@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1453566224" class="tooltipped" data-tooltip="QQ联系我: 1453566224" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


</body>
</html>