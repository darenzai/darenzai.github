<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux文本编辑器使用</title>
      <link href="/2019/11/10/linux-wen-ben-bian-ji-qi-shi-yong/"/>
      <url>/2019/11/10/linux-wen-ben-bian-ji-qi-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux文本编辑器使用"><a href="#Linux文本编辑器使用" class="headerlink" title="Linux文本编辑器使用"></a>Linux文本编辑器使用</h1><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>Vi命令是Unix操作系统和类Unix操作系统中最通用的全屏幕纯文本编辑器。Linux中的Vi编辑器叫Vim，它是Vi的增强版（Vi Improved），与Vi编辑器完全兼容，而且实现了很多增强功能。</p><p> Vi编辑器支持命令模式、编辑模式和末行模式。</p><p>命令模式：在该模式下是不能对文件直接编辑，可以输入快捷键进行一些操作（删除行，复制行，移动光标，粘贴等等）【打开文件之后默认进入的模式】；</p><p> 编辑模式：在该模式下可以完成文本的编辑功能；</p><p>末行模式：可以在末行输入命令来对文件进行操作（搜索、替换、保存、退出、撤销、高亮等等）；</p><p>要正确使用Vi编辑器就必须熟练掌握着两种模式的切换。默认情况下，打开Vi编辑器后自动进入一般模式。从编辑模式切换到命令模式使用“Esc”键，从命令模式切换到编辑模式使用“A”、“a”、“O”、“o”、“I”、“i”键。</p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/pKLktdzTDnGF.png?imageslim" alt="mark"></p><h3 id="Vim的打开文件的方式（要求掌握的就前三种）："><a href="#Vim的打开文件的方式（要求掌握的就前三种）：" class="headerlink" title="Vim的打开文件的方式（要求掌握的就前三种）："></a>Vim的打开文件的方式（要求掌握的就前三种）：</h3><p><strong>（1）#vim 文件路径</strong>  </p><p>​    作用：打开指定的文件</p><p><strong>（2）#vim  +数字  文件的路径</strong>  </p><p>​    作用：打开指定的文件，并且将光标移动到指定行</p><p><strong>（3）#vim  +/关键词  文件的路径</strong>  </p><p>​    作用：打开指定的文件，并且高亮显示关键词</p><p><strong>（4）#vim 文件路径1 文件路径2 文件路径3</strong>   </p><p>​    作用：同时打开多个文件，进入末行模式： “:open file1 ”</p><p><strong>（5）vim -on file1 file2 …其中:</strong></p><p>​    o(是小写字母o,不是数字零)n(表示你要分屏的文件个数)</p><p>作用：vim水平分屏的使用 ；文件之间的切换（ctrl+w）</p><p>（6）<strong>vim -On file1 file2 …..</strong></p><p>​    其中:O(是大写字母O,不是数字零)n(表示你要分屏的文件个数)</p><p>作用：vim垂直分屏；文件之间的切换（ctrl+w）</p><h3 id="（一）命令模式"><a href="#（一）命令模式" class="headerlink" title="（一）命令模式"></a><strong>（一）</strong>命令模式</h3><p>注意：该模式是打开文件的第一个看到的模式（打开文件即可进入）</p><h4 id="1、光标移动"><a href="#1、光标移动" class="headerlink" title="1、光标移动"></a><strong>1</strong>、光标移动</h4><p><em>①光标移动到行首</em></p><p>​    按键：shift + 6 或 ^（T字母上面的6，不要按小键盘的6）</p><p> <em>②光标移动到行尾</em></p><p>​    按键：shift + 4 或 $（R字母的左上角的4，不是小键盘的4）</p><p> <em>③光标移动到首行</em></p><p>​    按键：gg</p><p> <em>④光标移动到末行</em></p><p>​    按键：G</p><p> <em>⑤翻屏</em>    </p><p>​    向上翻屏：按键ctrl + b   （before）或   PgUp</p><p>​    向下翻屏：按键ctrl + f     （after）或       PgDn</p><h4 id="2、复制操作"><a href="#2、复制操作" class="headerlink" title="2、复制操作"></a>2<strong>、复制操作</strong></h4><p><em>①复制光标所在行</em></p><p>​    按键：yy</p><p>​    粘贴：在想要粘贴的地方按下p键</p><p><em>②以光标所在行为准（包含当前行），向下复制指定的行数</em></p><p>​    按键：数字yy</p><p><em>③可视化复制</em></p><p>​    按键：ctrl + v（可视块）或V（可视行）或v（可视），然后按下↑↓←→方向键来选中需要复制的区块，按下y    键进行复制，最后按下p键粘贴</p><p>###### </p><h5 id="4、撤销-恢复"><a href="#4、撤销-恢复" class="headerlink" title="4、撤销/恢复**"></a><strong>4</strong>、撤销<strong><strong>/</strong></strong>恢复**</h5><p>​    撤销：输入:u （不属于命令模式）  或者   u  （undo）</p><p>​    恢复：ctrl + r  恢复（取消）之前的撤销操作</p><h5 id="5、扩展1：光标的快速移动"><a href="#5、扩展1：光标的快速移动" class="headerlink" title="5、扩展1：光标的快速移动**"></a><strong>5</strong>、扩展<strong><strong>1</strong></strong>：光标的快速移动**</h5><p>​    <em>①快速将光标移动到指定的行</em></p><p>按键：数字G    </p><p>​    <strong><strong>②以当前光标为准向上/向下移动n行</strong></strong></p><p>按键：数字↑，数字↓</p><p><em>③以当前光标为准向左/向右移动n字符</em></p><p>按键：数字←，数字→</p><p><em>④末行模式下的快速移动方式：移动到指定的行</em></p><p>按键：输入英文“:”，其后输入行数数字，按下回车</p><h3 id="（二）、末行模式"><a href="#（二）、末行模式" class="headerlink" title="（二）、末行模式"></a><strong>（二）</strong>、末行模式</h3><p>进入方式：由命令模式进入，按下“:”或者“/（表示查找）”即可进入</p><p>退出方式：</p><pre><code>  a. 按下esc  b. 连按2次esc键</code></pre><p>​      c. 删除末行全部输入字符</p><p> <em>①保存操作（write）</em></p><p>​    输入：“:w”  保存文件</p><p>​    输入：“:w  路径”  另存为 </p><p><em>②退出（quit）</em></p><p>​    输入：“:q”  退出文件</p><p><em>③保存并退出</em></p><p>​    输入：“:wq”  保存并且退出</p><p><em>④强制 （!）</em></p><p>​    输入：“:q!”  表示强制退出，刚才做的修改操作不做保存</p><p><em>⑤搜索/查找</em></p><p>​    输入：“/关键词”然后回车“Enter”</p><p>​    例如：我想在passwd文件中搜索“sbin”关键词</p><p><strong>在搜索结果中切换上</strong>/下一个结果：N/n <strong>（</strong>next）</p><p>如果需要取消高亮，则需要输入：“:nohl”【no highlight】</p><p><em>⑥替换</em></p><p>​    :s/搜索的关键词/新的内容  替换光标所在行的第一处符合条件的内容</p><p>​    :s/搜索的关键词/新的内容/g  替换光标所在行的全部符合条件的内容</p><p>​    :%s/搜索的关键词/新的内容  替换整个文档中每行第一个符合条件的内容</p><p>​    :%s/搜索的关键词/新的内容/g  替换整个文档的符合条件的内容</p><p>%表示整个文件</p><p>g表示全局（global）</p><p><em>⑦显示行号（临时）</em></p><p>输入：“<strong><em>:set nu</em></strong>”[number]</p><p>如果想取消显示，则输入：“:set nonu”</p><h3 id="按键操作"><a href="#按键操作" class="headerlink" title="按键操作"></a>按键操作</h3><p>​        按『sp』                分页显示</p><p>​        按『close』           关闭当前页面</p><p>​        按『new』             新建页面</p><p>​        按『wqall』           退出并保存所有页面</p><p>​        按『qall!』             不保存退出所有页面</p><p>​        按『ctrl+w』          页面之间切换</p><p>​        按『e』filename    打开文本文件</p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/9HwlAaxzakO6.png?imageslim" alt="mark"></p><p>​    重点看前2个进入方式：i（insert）、a（after）。</p><p>​    退出方式：按下esc键</p><p>​        .vimrc是Vim的配置文件，通过此文件可以对用户的Vim的使用环境进行定制。.vimrc是隐藏文件，保存在用    户的主目录里。</p><p>​     </p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">         set</span> <span class="token attr-value">nu                    显示行号 </span><span class="token attr-name">​</span> <span class="token attr-value">       syntax on                 语法高亮度显示</span><span class="token attr-name">​</span> <span class="token attr-value">       set ruler                 底部显示行列号</span><span class="token attr-name">​</span> <span class="token attr-value">       set autoindent            使用自动对齐</span><span class="token attr-name">​</span> <span class="token attr-value">       set smartindent           智能的选择对齐方式</span><span class="token attr-name">​</span> <span class="token attr-value">       set background=dark       背景使用黑色</span><span class="token attr-name">​</span> <span class="token attr-value">       set cursorline            突出显示当前行</span><span class="token attr-name">​</span> <span class="token attr-value">       set tabstop=4             设定 tab 长度为 4</span></code></pre><p>[引用自老师的PPT]: </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程复习</title>
      <link href="/2019/05/21/linux-jin-cheng-fu-xi/"/>
      <url>/2019/05/21/linux-jin-cheng-fu-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux进程复习"><a href="#Linux进程复习" class="headerlink" title="Linux进程复习"></a>Linux进程复习</h1><h3 id="指令：ps"><a href="#指令：ps" class="headerlink" title="指令：ps"></a>指令：ps</h3><p>显示当前用户的进程</p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/OD0TMX8r3Rnw.png?imageslim" alt="mark"></p><h3 id="指令：ps-aux"><a href="#指令：ps-aux" class="headerlink" title="指令：ps aux"></a>指令：ps aux</h3><p>显示所有进程详细信息</p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/18DfE9cVwcKV.png?imageslim" alt="mark"></p><h3 id="指令：ps-ef"><a href="#指令：ps-ef" class="headerlink" title="指令：ps - ef"></a>指令：ps - ef</h3><p>显示所有进程详细信息</p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/im6QYKzxN9gc.png?imageslim" alt="mark"></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/zb5NErqe4np0.png?imageslim" alt="mark"></p><h3 id="指令-：ps-ef-grep-进程名"><a href="#指令-：ps-ef-grep-进程名" class="headerlink" title="指令 ：ps -ef|grep  进程名"></a>指令 ：ps -ef|grep  进程名</h3><p>过滤出想要的进程信息</p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/B6XWS9DQJ433.png?imageslim" alt="mark"></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/HQdGbLlGnJs7.png?imageslim" alt="mark"></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/L2ukbxmWLDPP.png?imageslim" alt="mark"></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/XGj63TLUeu2b.png?imageslim" alt="mark"></p><h3 id="指令：pstree"><a href="#指令：pstree" class="headerlink" title="指令：pstree"></a>指令：pstree</h3><p>功能：使用树形结构显示进程间的关系</p><p>格式：pstree  【选项】  【进程号或者进程名】</p><p>使用说明：</p><p>​        如果不指定进程号或用户名称，则会把系统启动时的第一个进程视为根，并显示之后的所有进程。若指定用户名称，便会以隶属该用户的第一个进程当作根，然后显示该用户的所有进程。</p><p>​        选项：</p><p>​        -a 　显示每个程序的完整指令，包含路径，参数或是常驻服务的标示</p><p>　　-c 　不使用精简标示法</p><p>　　-h 　列出树状图时，特别标明现在执行的程序</p><p>　　-l 　采用长列格式显示树状图</p><p>　　-n 　用进程号排序。预设是以程序名称来排序</p><p>　　-p 　显示进程号</p><p>　　-u 　显示用户名称</p><p>　　-V 　显示版本信息</p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/q25vG7U8MNbw.png?imageslim" alt="mark"></p><h3 id="指令：kill"><a href="#指令：kill" class="headerlink" title="指令：kill"></a>指令：kill</h3><p>表示杀死进程</p><p>ps -ef  查看进程   </p><p>为了避免杀死某些进程我就不展示了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序+SSM项目文档</title>
      <link href="/2019/04/27/qin-shi-zhu-shou-wen-dang/"/>
      <url>/2019/04/27/qin-shi-zhu-shou-wen-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g3akkdp1z7j31bv0pegsn.jpg" alt></p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432wgms0jj317q0kx7fn.jpg" alt></p><p>前端用微信小程序搭建，后端主要用到了目前开发常用的SSM框架(Spring+Spring+Mybatis)</p><p>首先阐述一下我们为什么要编写一款关于检查卫生的小程序</p><p>我以前是系里生卫部的成员，我们在检查卫生的时候是用笔记在本子上，在有的宿舍有很多条的时候写起来很</p><p>麻烦，而且还要每个宿舍对打扫不合格的地方用手机拍下来，图片分辨宿舍的时候需要用QQ画笔一个一个宿舍</p><p>写上去，而且辅导员老师也不利于实时关注宿舍卫生情况，很麻烦 就像下面这样</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432xdct6jj30bz0c675n.jpg" alt="1558544888842"></p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432xqlzmhj30oh0fvk35.jpg" alt="1558544923355"></p><p>而这个小程序就可以替代这些功能大大节省检查卫生人员的时间</p><p>我现在的权限是管理员 不是超级管理员所以只能展示管理员的功能</p><p>1，个人界面</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432y3omdnj305m09vgmg.jpg" alt="1558545061832"></p><p>2，提交宿舍检查卫生的情况</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432yge2l6j306i0bpwf1.jpg" alt="1558545163433"></p><p>3，对宿舍卫生情况进行查询，可以显示最近的检查和历史数据</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432yr0fdfj306f0bo75d.jpg" alt="1558545235584"></p><p>我们以60分为标准 低于六十分文字变红</p><p><img src="assets/1558545307423.png" alt="1558545307423"></p><p>如果数据添加错误可以对数据进行修改</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432z2lx7gj305i09xjrp.jpg" alt="1558545361862"></p><p>对所有卫生成绩进行查询（只显示最近查询的的一次，若看历史数据点开宿舍就可以看到）</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432zc3c8nj305e09w74k.jpg" alt="1558545541559"></p><p>代码结构目录</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g433026ybkj30d70ej0u3.jpg" alt="1558548116498"></p><p>由于考虑的以后可能会出现大量的查询请求我们开启了Mybatis的二级缓存（虽然有一定的缺陷但是用在这里还是可以的）</p><p>​    </p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cacheEnable<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 在mapper.xml 中设置开启--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span> <span class="token attr-name">eviction</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>LRU<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cache</span><span class="token punctuation">></span></span>并在java pojo中实现序列化接口public class noticBar implements Serializable{</code></pre><p>在一个就是应对大量的数据连接我们用C3P0 数据库连接池来管理</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>property-placeholder</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>classpath:dbconfig.properties<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pooledDataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mchange.v2.c3p0.ComboPooledDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbcUrl<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${jdbc.jdbcUrl}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driverClass<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${jdbc.driverClass}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${jdbc.user}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${jdbc.password}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>acquireIncrement<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>${c3p0.acquireIncrement}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--初始化时获取三个连接，取值应在minPoolSize与maxPoolSize之间。Default: 3 --></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>initialPoolSize<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>${c3p0.initialPoolSize}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>minPoolSize<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>${c3p0.minPoolSize}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maxPoolSize<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>${c3p0.maxPoolSize}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maxIdleTime<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>${c3p0.maxIdleTime}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--每60秒检查所有连接池中的空闲连接。Default: 0 --></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>idleConnectionTestPeriod<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>${c3p0.idleConnectionTestPeriod}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p>为了方便我们参数从perpropties文件引入</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g4330pls0mj30m00533yp.jpg" alt="1558546874535"></p><p>还有一个问题就是数据校验 引入JSR303数据校验（未前端进行交互）</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Size</span><span class="token punctuation">(</span>min<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span>max<span class="token operator">=</span><span class="token number">701</span><span class="token punctuation">,</span>message<span class="token operator">=</span><span class="token string">"{Swb.hostelId.length.error}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> hostelId<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//宿舍号</span></code></pre><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g43310bptxj30gt01xa9y.jpg" alt="1558594316368"></p><p>由于我们前端数据发送过来的时候 调用同一个方法会造成并发问题</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g4331iwontj30ha07qahn.jpg" alt="1558547366433"></p><p>我们在方法上加一个锁 关键字 <strong>synchronized</strong> 让这个方法每次只能一个线程访问，当然这情况会消耗一些服务器的性能</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ResponseBody</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/add"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">addS</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>            <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"file"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> MultipartFile file<span class="token punctuation">,</span>            <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"swb"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> Swb swb    <span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalStateException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span></code></pre><p>再者项目要发布到服务器 有些错误需要记录下来 还有为了防止检查人员徇私舞弊我们对敏感操作添加了log4j日志，进行记录</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">log4j.appender.logfile.File</span> <span class="token punctuation">=</span><span class="token attr-value">/usr/***/log4j.log</span><span class="token comment" spellcheck="true">#日志的最大容量为10M</span><span class="token comment" spellcheck="true">#log4j.appender.logfile.maxFileSize=10240KB </span><span class="token comment" spellcheck="true">#是否追加写进文件    </span><span class="token attr-name">log4j.appender.logfile.Append</span> <span class="token punctuation">=</span> <span class="token attr-value">true   </span><span class="token comment" spellcheck="true">#输出DEBUG级别日志到文件中 </span><span class="token attr-name">log4j.appender.logfile.Threshold</span> <span class="token punctuation">=</span> <span class="token attr-value">DEBUG    </span><span class="token attr-name">log4j.appender.logfile.layout</span> <span class="token punctuation">=</span> <span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.logfile.layout.ConversionPattern</span> <span class="token punctuation">=</span> <span class="token attr-value">%d [%t] %-5p %c - %m%n</span></code></pre><p>在程序发布的时候我们就是靠着查看Linux上我们配置的日志文件解决了一个又一个Bug</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g4332oonr8j30y104smxx.jpg" alt="1558548007405"></p><p>代码逻辑</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g433308ae0j30zx0b7wf8.jpg" alt="1558548223298"></p><p>在配置文件中对Spring事务 的get方法进行增强</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.jdbc.datasource.DataSourceTransactionManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--控制住数据源  --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pooledDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--开启基于注解的事务，使用xml配置形式的事务（必要主要的都是使用配置式）  --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 切入点表达式 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>pointcut</span> <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>execution(* com.dbteam.serviceIml..*(..))<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>txPoint<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 配置事务增强 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>advisor</span> <span class="token attr-name">advice-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>txAdvice<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>txPoint<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--配置事务增强，事务如何切入  --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>advice</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>txAdvice<span class="token punctuation">"</span></span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 所有方法都是事务方法 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>*<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token comment" spellcheck="true">&lt;!--以get开始的所有方法  优化 事物增强--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>get*<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>advice</span><span class="token punctuation">></span></span></code></pre><p>建表语句</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g4333ibfksj30b406dmxv.jpg" alt="1558594697788"></p><p><strong>不足：</strong></p><p><strong>1，还是没有解决高并发问题，对高并发知识点掌握薄弱，</strong></p><p><strong>2，没有引用其他第三方缓存，而是用Mybatis自带的二级缓存，</strong></p><p><strong>3，对代码优化比较少，</strong></p><p><strong>4，代码结构有点混乱，有冗余的地方</strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件系统复习</title>
      <link href="/2019/04/12/linux-wen-jian-xi-tong-fu-xi/"/>
      <url>/2019/04/12/linux-wen-jian-xi-tong-fu-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux文件系统复习"><a href="#Linux文件系统复习" class="headerlink" title="Linux文件系统复习"></a><strong>Linux文件系统复习</strong></h1><h4 id="Linux系统目录"><a href="#Linux系统目录" class="headerlink" title="Linux系统目录"></a><strong>Linux系统目录</strong></h4><table><thead><tr><th><strong>常见的Linux系统目录如下：</strong></th></tr></thead><tbody><tr><td><strong>/：Linux系统的根目录，包含Linux系统所有目录和文件。</strong></td></tr><tr><td><strong>/etc：有关系统设备与管理的配置文件。</strong></td></tr><tr><td><strong>/sbin：存放系统启动时所需的运行程序。</strong></td></tr><tr><td><strong>/bin：该目录中含有常用的命令文件，不能包含子目录。</strong></td></tr><tr><td><strong>/boot：操作系统启动时的核心文件。</strong></td></tr><tr><td><strong>/usr/local：存放用户后期安装的应用程序文件。</strong></td></tr><tr><td><strong>/root：超级用户主目录。</strong></td></tr><tr><td><strong>/dev：接口设备文件目录，保存外围设备代号。</strong></td></tr><tr><td><strong>/mnt：设备文件的挂接点，默认有/mnt/cdrom和/mnt/floppy两个目录，分别用于挂载光驱和软驱。</strong></td></tr><tr><td><strong>/</strong></td></tr><tr><td><strong>home</strong></td></tr><tr><td><strong>：用户的宿主目录，通常将其设置在独立的分区</strong></td></tr></tbody></table><h3 id="输出重定向指令"><a href="#输出重定向指令" class="headerlink" title="输出重定向指令"></a><strong>输出重定向指令</strong></h3><p><strong>一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要</strong></p><p><strong>保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术。</strong></p><p><strong>&gt; ：覆盖输出，会覆盖掉原先的文件内容</strong></p><p><strong>&gt;&gt;：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加</strong></p><p><strong>ls &gt;&gt;+文件名</strong> </p><p><strong>输出追加重定向，不存在会创建出来，把显示的目录文件都放到txt中保存</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/Y7oE12mIpSTd.png?imageslim" alt="mark"></p><h3 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a><strong>pwd指令</strong></h3><p><strong>用法：#pwd</strong></p><p><strong>含义：（print working directory，打印当前工作目录）</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/D6emYU5R1p0J.png?imageslim" alt="1560843243722"></p><h3 id="指令：mkdir"><a href="#指令：mkdir" class="headerlink" title="指令：mkdir"></a><strong>指令：mkdir</strong></h3><p><strong>含义：（make directory，创建目录）</strong></p><p><strong>注意：ls列出的结果颜色说明，其中蓝色的名称表示文件夹，白色的表示文件，绿色的其权限为拥有所有权限。</strong></p><p><strong><img src="assets/1560843349685.png" alt="1560843349685"></strong></p><p><strong>语法2：#mkdir</strong> -p 路径****</p><p><strong>含义：当一次性创建多层不存在的目录的时候，添加-p参数，否则会报错</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/QUaoJcawdwY1.png?imageslim" alt="mark">**</p><p><strong>语法3：#mkdir</strong> 路径1 路径2 路径3 ….  【表示一次性创建多个目录】****</p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/94v8tBYw0Vqw.png?imageslim" alt="mark">**</p><h3 id="指令：touch"><a href="#指令：touch" class="headerlink" title="指令：touch"></a><strong>指令：touch</strong></h3><p><strong>作用：创建文件</strong></p><p><strong>语法：#touch 文件路径  【路径可以是直接的文件名也可以是路径】</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/S5eETL7K4zCk.png?imageslim" alt="mark">**</p><h3 id="指令：cp-（copy，复制）"><a href="#指令：cp-（copy，复制）" class="headerlink" title="指令：cp  （copy，复制）"></a><strong>指令：cp  （copy，复制）</strong></h3><p><strong>作用：复制文件/文件夹到指定的位置</strong></p><p><strong>语法：#cp</strong>    被复制的文档路径    文档被复制到的路径****</p><p><strong>注意：Linux在复制过程中是可以重新对新位置的文件进行重命名的，</strong><br><strong>但是如果不是必须的需要，则建议保持前后名称一致。**</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/rE1dk5GKE1iT.png?imageslim" alt="mark">**</p><p><strong>当使用cp命令进行文件夹复制操作的时候需要添加选项“-r”**</strong></p><p><strong>【-r表示递归复制】，否则目录将被忽略</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/XKs3iORstct7.png?imageslim" alt="mark">**</p><h3 id="指令：mv-（move，移动，剪切）"><a href="#指令：mv-（move，移动，剪切）" class="headerlink" title="指令：mv   （move，移动，剪切）"></a><strong>指令：mv   （move，移动，剪切）</strong></h3><p><strong>作用：移动文档到新的位置</strong></p><p><strong>语法：#mv 需要移动的文档路径  需要保存的位置路径**</strong></p><p><strong>确认：移动之后原始的文件还在不在原来的位置？原始文件是不在原始位置的</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/P9rerb3X2c7R.png?imageslim" alt="mark">**</p><h3 id="指令：rm-（remove，移除、删除）"><a href="#指令：rm-（remove，移除、删除）" class="headerlink" title="指令：rm （remove，移除、删除）"></a><strong>指令：rm （remove，移除、删除）</strong></h3><p><strong>作用：移除/删除文档</strong></p><p><strong>语法：#rm 选项 需要移除的文档路径</strong></p><p><strong>选项：</strong></p><p>  <strong>-f：force，强制删除，不提示是否删除</strong></p><hr><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/PaTlBr36zeI0.png?imageslim" alt="mark">**</p><p><strong>-r： r递归删除，删除一个完整目录及其子目录</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/uPL4H70Axmpo.png?imageslim" alt="mark">**</p><h3 id="指令-cat"><a href="#指令-cat" class="headerlink" title="指令 cat**"></a>指令 cat**</h3><p><strong>-A：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</strong></p><p><strong>-b：列出行号，仅针对非空白行做行号显示，空白行不标行号！</strong></p><p><strong>-E：将结尾的断行字符 $ 显示出来；</strong></p><p><strong>-n：打印出行号，连同空白行也会有行号，与 -b 的选项不同；</strong></p><p><strong>-T：将 [tab] 按键以 ^I 显示出来；</strong></p><p><strong>-v：列出一些看不出来的特殊字符</strong></p><p><strong>cat -n 打印行号**</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/8HT3u8OWARlV.png?imageslim" alt="mark">**</p><p><strong>cat -b 列出行号，仅针对非空白行做行号显示，空白行不标行号！</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/M3TNngjQJtAa.png?imageslim" alt="mark">**</p><p><strong>-T：将 [tab]</strong><br><strong>按键以 ^I 显示出来；</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/hzx7nWOwgAQ0.png?imageslim" alt="mark">**</p><p><strong>-v 列出一些特殊字符</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/VpOQBd9gYiE7.png?imageslim" alt="mark">**</p><h3 id="nl指令"><a href="#nl指令" class="headerlink" title="nl指令"></a><strong>nl指令</strong></h3><p>​        <strong>功能：以输出行号的方式显示文件。</strong></p><p>​        <strong>格式：nl  [选项] [文件名]</strong></p><p>​        <strong>使用说明：</strong></p><p>​        <strong>nl命令和cat命令很像，不过nl命令会输出行号。</strong></p><p>​        <strong>选项：</strong></p><p>​        <strong>-b指定行号指定的方式，主要有两种：</strong></p><p>　　    <strong>-b a：表示不论是否为空行，也同样列出行号（类似 cat -n）</strong></p><p>　　    <strong>-b t：如果有空行，空的那一行不要列出行号（默认值）</strong></p><p>　　<strong>-n列出行号表示的方法，主要有三种：</strong></p><p>　　    <strong>-n ln ：行号在萤幕的最左方显示</strong></p><p>　　    <strong>-n rn ：行号在自己栏位的最右方显示，且不加 0</strong></p><p>　　    <strong>-n rz ：行号在自己栏位的最右方显示，且加 0</strong></p><p>　　<strong>-w行号栏位的占用的位数</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/rdHvjPTGy7wI.png?imageslim" alt="mark">**</p><h3 id="man-指令"><a href="#man-指令" class="headerlink" title="man 指令"></a><strong>man 指令</strong></h3><p><strong>作用：manual，手册（包含了Linux中全部命令手册，英文）</strong></p><p><strong>语法：#man 命令  （退出按下q键）</strong></p><hr><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/nIiyIOtyg8JK.png?imageslim" alt="mark">**</p><h3 id="uptime指令"><a href="#uptime指令" class="headerlink" title="uptime指令"></a><strong>uptime</strong>指令</h3><p><strong>作用：输出计算机的持续在线时间（计算机从开机到现在运行的时间）</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/2sYva5VOCB66.png?imageslim" alt="mark">**</p><h3 id="ifconfig指令"><a href="#ifconfig指令" class="headerlink" title="ifconfig指令"></a><strong>ifconfig</strong>指令</h3><p><strong>作用：用于操作网卡相关的指令。</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/TrmUVxT02Ert.png?imageslim" alt="mark">**</p><h3 id="uname-指令"><a href="#uname-指令" class="headerlink" title="uname 指令"></a><strong>uname 指令</strong></h3><p><strong>获取计算机操作系统相关信息</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/K2JXkGeT1E8N.png?imageslim" alt="mark">**</p><h3 id="netstat-指令"><a href="#netstat-指令" class="headerlink" title="netstat 指令**"></a>netstat 指令**</h3><p><strong>查看网络的连接状态</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/ic4CHhNyx2ex.png?imageslim" alt="mark">**</p><p><strong>-t 表示只列出tcp协议的连接</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/2ACyo1qmF5lC.png?imageslim" alt="mark">**</p><p><strong>-p：表示显示发起连接的进程pid和进程名称；</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/yzHUNpJBx7P0.png?imageslim" alt="mark">**</p><p><strong>-n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/xF1semWtsJOO.png?imageslim" alt="mark">**</p><h3 id="指令file-确定文件类型"><a href="#指令file-确定文件类型" class="headerlink" title="指令file(确定文件类型)"></a><strong>指令file(确定文件类型)</strong></h3><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/z81qoUUWGBSe.png?imageslim" alt="mark"></p><h3 id="find指令"><a href="#find指令" class="headerlink" title="find指令****"></a><strong>find</strong>指令****</h3><p><strong>作用：用于查找文件（其参数有55个之多）</strong></p><p><strong>语法：#find 路径范围 选项 选项的值</strong></p><p><strong>选项：</strong></p><p>​         <strong>-name：按照文档名称进行搜索（支持模糊搜索）</strong></p><p>​         <strong>-type：按照文档的类型进行搜索</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190618/pwrBAzHxhNFM.png?imageslim" alt="mark">**</p><p><strong>-name 根据文件名查找文件</strong></p><p><strong><img src="!%5Bmark%5D(http://ptagesjik.bkt.clouddn.com/blog/20190618/qYVomylHY0kc.png?imageslim)" alt="1560824116988"></strong></p><p><strong>-name ‘*.txt’ 搜索目录下所有txt后戳的文件。</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/Jl43B91KhNo3.png?imageslim" alt="mark">**</p><p><strong>使用find来搜索目录下所有的文件夹</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/6aLoXNQCifER.png?imageslim" alt="mark">**</p><p><strong>搜索文件夹下所有文件</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/HVnojs3n9vhV.png?imageslim" alt="mark">**</p><h3 id="which指令"><a href="#which指令" class="headerlink" title="which指令"></a><strong>which</strong>指令</h3><p><strong>作用：</strong></p><p><strong>查看可执行文件的位置</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/1jLhuMBvMN8R.png?imageslim" alt="mark">**</p><h3 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a><strong>locate</strong>指令</h3><p>​        <strong>功能：查看文件位置。<img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/pLsTOTr7STYk.png?imageslim" alt="mark"></strong></p><h3 id="df指令"><a href="#df指令" class="headerlink" title="df指令"></a><strong>df</strong>指令</h3><p><strong>作用：查看磁盘的空间</strong></p><p><strong>语法：</strong>#df -h  -h表示以可读性较高的形式展示大小****</p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/VxBz0zvdm2yT.png?imageslim" alt="mark">**</p><p><strong>df -h</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/sSUgY4cbCDQc.png?imageslim" alt="mark">** </p><h3 id="free指令"><a href="#free指令" class="headerlink" title="free指令"></a><strong>free</strong>指令</h3><p><strong>作用：查看内存使用情况</strong></p><p><strong>语法：</strong>#free -m   -m表示以mb为单位查看，-h表示以可读性较高的形式展示大小****</p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/UdVG85G35DLJ.png?imageslim" alt="mark">**</p><p><strong>-m 以mb的形式查看</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/OUeOqCfoOu1X.png?imageslim" alt="mark">**</p><p><strong>-h 以高可读性形式显示</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/fcwGscp9HRom.png?imageslim" alt="mark">**</p><h3 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a><strong>head</strong>指令</h3><p><strong>作用：查看一个文件的前n行，如果不指定n，则默认显示前10行。</strong></p><p><strong>语法：</strong>#head  -n**  文件路径   【n<strong>表示数字】**</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/2OyBE9HBqAKN.png?imageslim" alt="mark">**</p><h3 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a><strong>tail</strong>指令</h3><p><strong>作用1：查看一个文件的未n行，如果n不指定默认显示后10行</strong></p><p><strong>语法：</strong>#tail  -n**  文件的路径    n<strong>同样表示数字**</strong></p><p><strong><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/eB5y2oev0mJE.png?imageslim" alt="mark"></strong></p><p><strong>tail -f</strong></p><p><strong>该命令一般用于查看系统的日志比较多。</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/7yQNT7ll4G6b.png?imageslim" alt="mark">**</p><h3 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a><strong>less指令</strong></h3><p><strong>查看文件，以较少的内容进行输出，按下辅助功能键（数字+回车、空格键+上下方向键）查看更多</strong></p><p><strong>语法：</strong>#less**  需要查看的文件路径**</p><p><strong>在退出的只需要按下q键即可。</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/wgtf12Q2qI26.png?imageslim" alt="mark">**</p><h3 id="wc指令"><a href="#wc指令" class="headerlink" title="wc指令"></a><strong>wc</strong>指令</h3><p><strong>作用：统计文件内容信息（包含行数、单词数、字节数）</strong></p><p><strong>语法：#</strong>wc**  -<strong>lwc</strong> 需要统计的文件路径**</p><p>  <strong>-l</strong>：表示lines，行数****</p><p>  <strong>-w：表示words，单词数   依照空格来判断单词数量</strong></p><p>  <strong>-c：表示bytes，字节数</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/aubqUpxkgzMs.png?imageslim" alt="mark">**</p><h3 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a><strong>date指令</strong></h3><p><strong>作用：表示操作时间日期（读取、设置）</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/U0OkDDI0FOL5.png?imageslim" alt="mark">**</p><p><strong>#date  +%F</strong></p><p><strong><img src="assets/1560828119770.png" alt="1560828119770"></strong></p><p><strong>\</strong></p><p><strong>#date  “+%F %T”    引号表示让“年月日与时分秒”成为一个不可分割的整体</strong></p><p><strong>%F：表示完整的年月日             %d：表示日期（带前导0）</strong></p><p><strong>%T：表示完整的时分秒            %H：表示小时（带前导0）</strong></p><p><strong>%Y：表示四位年份                %M：表示分钟（带前导0）</strong></p><p><strong>%m：表示两位月份（带前导0）     %S：表示秒数（带前导0）    <img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/KQ2btu8LUaDu.png?imageslim" alt="mark"></strong></p><h3 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令****"></a><strong>cal</strong>指令****</h3><p><strong>作用：用来操作日历的</strong></p><p><strong>#</strong>cal**    等价于 #<strong>cal</strong>  -1  直接输出当前月份的日历**</p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/A3nTulbBn2Xv.png?imageslim" alt="mark">**</p><hr><p><strong>cal</strong>  -3**</p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/PJlw7gNCufj3.png?imageslim" alt="mark">**</p><p><strong>cal -y 年份</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/pRj7mBWbl11C.png?imageslim" alt="mark">**</p><h3 id="grep指令"><a href="#grep指令" class="headerlink" title="grep指令"></a>grep指令</h3><p><strong>grep命令用于查找文件中包含有指定字符串的行。</strong></p><p><strong>常用的选项：</strong></p><p><strong>•-v：列出不匹配的行</strong></p><p><strong>•-c：对匹配的行计数</strong></p><p><strong>•-l：只显示包含匹配模式的文件名</strong></p><p><strong>•-h：抑制包含匹配模式的文件名的显示</strong></p><p><strong>•-n:每个匹配行只按照相对的行号显示</strong></p><p><strong>•-i:对匹配模式不区分大小写</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/FWzsSS9kHmnq.png?imageslim" alt="mark">**</p><h3 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h3><p><strong>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。</strong><br><strong>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz</strong></p><p><strong>选项：</strong></p><p>​        <strong>1. 主选项</strong></p><p>​        <strong>-c 创建压缩文档。相当于打包</strong></p><p>​        <strong>-x 解压</strong></p><p>​        <strong>-t 列出文档的内容，查看已经备份了哪些文件</strong></p><p>​        <strong>注意，在参数的下达中， c/x/t 仅能存在一个，不可同时存在，因为不可能同时压缩与解压缩。</strong></p><p>​        <strong>2. 辅选项</strong></p><p>​        <strong>-z 具有 gzip 的属性一般格式为xx.tar.gz或xx. tgz</strong></p><p>​        <strong>-j 具有 bzip2 的属性一般格式为xx.tar.bz2</strong>  </p><p>​        <strong>-v 压缩的过程中显示文件</strong></p><p>​        <strong>-f 将文件打包生成到一个文件里，这个选项通常是必选项</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/idIakAKa01oh.png?imageslim" alt="mark">**</p><p><strong>解压压缩包</strong><br><strong>命令：tar [-zxvf] 压缩文件</strong><br><strong>其中：x：代表解压</strong><br><strong>可以不用写</strong>z，写z代表指定压缩方式，可以自动识别<strong>** **示例：将/test下的txt.tar.gz解压到当前目录下</strong> </p><p><strong>示例：txt.tar.gz解压</strong><br><strong>tar -</strong>xvf** txt.tar.gz -C /<strong>usr——C代表指定解压的位置**</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/iyLjjKNY5yHG.png?imageslim" alt="mark">**</p><h3 id="gzip指令"><a href="#gzip指令" class="headerlink" title="gzip指令"></a>gzip指令</h3><p><strong>gzip命令用于对文件进行压缩，生成的文件以“.gz”结尾</strong></p><p><strong>语法：</strong><br><strong>gzip –v 文件名</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/G9RPqHu3TcDF.png?imageslim" alt="mark">**</p><p><strong>gunzip命令是对以“.gz”结尾的文件进行解压缩。</strong></p><p><strong>gunzip</strong><br><strong>-v 文件名</strong></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/z84j44fd9VLa.png?imageslim" alt="mark">**</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用git提交项目到Github</title>
      <link href="/2019/04/01/shi-yong-git-ti-jiao-xiang-mu-dao-github/"/>
      <url>/2019/04/01/shi-yong-git-ti-jiao-xiang-mu-dao-github/</url>
      
        <content type="html"><![CDATA[<h1 id="使用git提交项目到Github"><a href="#使用git提交项目到Github" class="headerlink" title="使用git提交项目到Github"></a>使用git提交项目到Github</h1><p>首先我们第一步我们打开我的git命令行窗口</p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/HWDHlFaMkMsd.png?imageslim" alt="mark"></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/xyvFHSW35A22.png?imageslim" alt="mark"></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/5pT0O2dFtvTT.png?imageslim" alt="mark"></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/iqPSxiYWNXy5.png?imageslim" alt="mark"></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/CXKP0vnxP3J8.png?imageslim" alt="mark"></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/Vncp41adiE2r.png?imageslim" alt="mark"></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/lQwiE7CIMo9A.png?imageslim" alt="mark"></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/i7zYQxyLjxji.png?imageslim" alt="mark"></p><p><img src="http://ptagesjik.bkt.clouddn.com/blog/20190619/Q33HhnfqnbXY.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端实训笔记（HTML5+CSS+Javascript）</title>
      <link href="/2019/03/27/qian-duan-shi-xun-bi-ji-html5-css-javascript/"/>
      <url>/2019/03/27/qian-duan-shi-xun-bi-ji-html5-css-javascript/</url>
      
        <content type="html"><![CDATA[<h2 id="前端实训笔记（HTML5-CSS-Javascript）"><a href="#前端实训笔记（HTML5-CSS-Javascript）" class="headerlink" title="前端实训笔记（HTML5+CSS+Javascript）"></a>前端实训笔记（HTML5+CSS+Javascript）</h2><h4 id="1-Java的平台"><a href="#1-Java的平台" class="headerlink" title="1 Java的平台"></a>1 Java的平台</h4><p>  1）JavaSE  Java平台的标准版 Java基础+Java高级  –&gt; Client（客户端）架构    Client(客户端)/Server（服务器端）架构<br>  2）JavaEE  Java平台的企业版 （互联网程序应用 -&gt;  Browser（浏览器）/Server（服务器）架构 ）  数据库  Web开发基础（HTML5 CSS JavaScript…） JSP Servlet SSH框架等<br>                                                                                                        Browser浏览器端的开发                Server服务器端的开发<br> Web开发基础<br> HTML5    一个HTML就是一个页面，主要是显示一个网页（页面）的内容<br> CSS      美化页面，样式<br> JavaScript 完成页面的动态效果</p><h4 id="2-互联网开发的工作流程-原理"><a href="#2-互联网开发的工作流程-原理" class="headerlink" title="2 互联网开发的工作流程/原理"></a>2 互联网开发的工作流程/原理</h4><p>​    浏览器端      服务器端      数据库端</p><h4 id="3-HTML"><a href="#3-HTML" class="headerlink" title="3 HTML"></a>3 HTML</h4><p>  HTML是一种标记语言，HTML的全称:Hypertext Markup Language,超文本标记语言。学习HTML，主要是在学习标记。<br>  HTML负责一个页面的内容，实现页面中的图片、超链接、按钮、列表、输入框等等。</p><h6 id="1）创建第一个HTML页面"><a href="#1）创建第一个HTML页面" class="headerlink" title="1）创建第一个HTML页面"></a>1）创建第一个HTML页面</h6><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">  Java程序：xx.java</span> <span class="token attr-value">   HelloWorld.java</span>    world文档：xx.doc<span class="token attr-name">    记事本文档</span><span class="token punctuation">:</span><span class="token attr-value">xx.txt</span>    html页面：xx.html</code></pre><h6 id="2）HTML文档的结构"><a href="#2）HTML文档的结构" class="headerlink" title="2）HTML文档的结构"></a>2）HTML文档的结构</h6><p>​    </p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">头</span> <span class="token attr-value"> &lt;head>&lt;/head></span><span class="token attr-name">    体</span> <span class="token attr-value"> &lt;body>&lt;/body></span><span class="token attr-name">    HTML文档的开始和结束：</span> <span class="token attr-value">&lt;html>&lt;/html></span><span class="token attr-name">    版本信息：&lt;!DOCTYPE</span> <span class="token attr-value">HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> 可以省略的</span></code></pre><h6 id="3）标记：是尖括号-lt-gt-包围的单词，很多标记都是成对出现的，一个是开始标记，一个是结束标记-lt-gt"><a href="#3）标记：是尖括号-lt-gt-包围的单词，很多标记都是成对出现的，一个是开始标记，一个是结束标记-lt-gt" class="headerlink" title="3）标记：是尖括号&lt;&gt;包围的单词，很多标记都是成对出现的，一个是开始标记，一个是结束标记&lt;/??&gt;"></a>3）标记：是尖括号&lt;&gt;包围的单词，很多标记都是成对出现的，一个是开始标记<??>，一个是结束标记&lt;/??&gt;</h6><h6 id="4）HTML中的专业术语"><a href="#4）HTML中的专业术语" class="headerlink" title="4）HTML中的专业术语"></a>4）HTML中的专业术语</h6><p>​    </p><pre class=" language-properties"><code class="language-properties">1）元素：每一对尖括号包围的部分，元素由三部分组成：开始标记、内容、结束标记    2）属性：用来修饰元素内容的，通常属性写在开始标记中</code></pre><h6 id="5）HTML中的注释："><a href="#5）HTML中的注释：" class="headerlink" title="5）HTML中的注释："></a>5）HTML中的注释：<!-- xxxxxx --></h6><h6 id="6）HTML中常用的标记"><a href="#6）HTML中常用的标记" class="headerlink" title="6）HTML中常用的标记"></a>6）HTML中常用的标记</h6><h6 id="一、写在头中的标记"><a href="#一、写在头中的标记" class="headerlink" title="一、写在头中的标记"></a>一、写在头<head><meta name="generator" content="Hexo 3.9.0">中的标记<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head></h6><p>​       </p><pre class=" language-html"><code class="language-html"> （1）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>标记：设置页面的标题        （2）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span><span class="token punctuation">></span></span>标记：a 设置页面自刷新                         b 设置页面中文编码        （3）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span>标记：在该标记中主要写JavaScript代码的        （4）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span>标记：写CSS代码的        （5）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span><span class="token punctuation">></span></span>标记：引入CSS代码的</code></pre><h6 id="二、写在体中的标记"><a href="#二、写在体中的标记" class="headerlink" title="二、写在体中的标记"></a>二、写在体<body>中的标记</body></h6><pre class=" language-css"><code class="language-css">    分类：​       行内标记：不会另起一行的标记 &lt;font> &lt;strong> &lt;em><span class="token number">...</span>​       块标记：会另起一行的标记 &lt;h<span class="token number">1</span>>~&lt;h<span class="token number">6</span>> &lt;center> &lt;p><span class="token number">...</span>######     （</code></pre><pre class=" language-html"><code class="language-html">###### 1）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>~<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h6</span><span class="token punctuation">></span></span>标记：标题标记，在HTML中设定了6个标题标记，分别为<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>~<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h6</span><span class="token punctuation">></span></span>标记，数字越小，级别越高 显示的文字越大，字体都是加粗的效果。######     （2）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span><span class="token punctuation">></span></span>标记：用于设置字体、字号（1-7）和颜色######     （3）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">></span></span>标记：加粗标记######     （4）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>标记：换行标记######     （5）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">></span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span><span class="token punctuation">></span></span>标记：斜体标记######     （6）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>u</span><span class="token punctuation">></span></span>标记：下划线标记######     （7）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>center</span><span class="token punctuation">></span></span>标记：居中标记######     （8）空格标记：转移标记的特点是&amp;开始，不用&lt;> <span class="token entity" title="&nbsp;">&amp;nbsp;</span>表示一个空格    （9）大于、小于标记：<span class="token entity" title="&lt;">&amp;lt;</span> 小于    <span class="token entity" title="&gt;">&amp;gt;</span>大于    （10）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>标记：段落标记，段落标记的特点在段前和段后各添加一个空行    （11）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">/></span></span>标记：在页面中画出一条水平线    （12）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>、<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>标记：div是典型的块标记，span是典型的行内标记                             典型在div只会另起一行，span不会另起一行，没有其他功能                             div和span常用于一个页面的布局######     （13）文字列表标记​        ①无序列表   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>​        ②有序列表   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>######     （14）超链接、图片标记​          ① 超链接：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span><span class="token punctuation">></span></span>标记  ​                       属性：href=""超链接的跳转地址​                             target=""超链接的跳转方式  _self本页面内部发生跳转的方式(默认)​                                                       _blank 新页面发生页面跳转的方式​          ② 图片：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span><span class="token punctuation">></span></span>标记​                     属性：src=""所显示的图片名称​                           width="" 设置图片的宽度​                           height="" 设置图片的高度​                           title=""设置鼠标指向图片时显示的标题​                                   （alt=""不建议用，有的浏览器不支持）​                           border=""设置图片的边框​           ③图片热点分割技术（将一张图片进行分割）：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">></span></span>标记​                   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span><span class="token punctuation">></span></span>分割的区域​                        shape="" 分割区域的形状 （rect矩形  circle圆）​                        coords="" 分割区域的坐标（左上,右下的坐标值   圆心,半径）​           ④返回页面顶部 href="#top"######     （15）表格标记          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>标记：表示表格的开始和结束          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>标记： 行          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>标记：列          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>caption</span><span class="token punctuation">></span></span>标记：表格的标题，存在于表格的正上方                         （写在table标记里，第一个tr的上面）          属性：            border=""：设置表格的边框            cellspacing=""：表格中行列之间的空隙（0~）            width="" :设置表格的宽度            height="" 设置表格的高度            align="" 水平对齐方式    left左对齐  center居中对齐  right右对齐               （在table标记中使用，让表格整体的左，中，右对齐                在tr标记中使用，让这一整行的内容左，中，右对齐                在td标记中使用，单独让一个单元格的内容左，中，右对齐               ）            valign=""垂直对齐方式 top顶部对齐 middle居中对齐 bottom底部对齐              （valign只能用在tr或者td中,不能在table标记中使用）​           表格的跨行和跨列​               跨行：从上往下垂直方向合并单元格  属性:rowspan="数字" 数字表示跨几行​               跨列：从左往右水平方向合并单元格  属性:colspan="数字" 数字表格跨几列​           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>marquee</span><span class="token punctuation">></span></span>标记：能够将标记中的内容做成漂移的效果</code></pre><h6 id="（16）表单标记"><a href="#（16）表单标记" class="headerlink" title="（16）表单标记"></a>（16）表单标记</h6><p>​     </p><pre class=" language-properties"><code class="language-properties">  表单：一个表中列出的很多单项，这些列出的单项可用于收集用户的信息。       比如输入框，单选按钮，多选按钮等都是表单中的单项。       表单的标记：&lt;form>       表单中的单项分类：         一、input标记系列<span class="token attr-name">           ①单行文本框</span> <span class="token attr-value">  type="text"</span><span class="token attr-name">           ②单行密码框</span> <span class="token attr-value">  type="password"</span><span class="token attr-name">           ③单选按钮</span> <span class="token attr-value">    type="radio"</span><span class="token attr-name">           ④多线按钮</span> <span class="token attr-value">    type="checkbox"</span><span class="token attr-name">           ⑤文件域</span> <span class="token attr-value">      type="file"</span><span class="token attr-name">           ⑥提交按钮</span> <span class="token attr-value">    type="submit"</span><span class="token attr-name">           ⑦重置按钮</span> <span class="token attr-value">    type="reset"</span><span class="token attr-name">           ⑧普通按钮</span> <span class="token attr-value">    type="button"</span><span class="token attr-name">           ⑨图片域(按钮)</span> <span class="token attr-value">type="image" 在表单中借助于input标记显示图片，</span>                                       该图片具有和提交按钮相同的功能<span class="token attr-name">           ⑩隐藏域</span> <span class="token attr-value">      type="hidden" 隐藏域用于将数传递给服务器端，</span>                                        但是不想在页面中看到<span class="token attr-name">​</span> <span class="token attr-value">        input标记中的常用属性：</span><span class="token attr-name">​</span> <span class="token attr-value">          type=""属性：</span><span class="token attr-name">​</span> <span class="token attr-value">          name=""属性：</span><span class="token attr-name">​</span> <span class="token attr-value">          value=""属性:</span><span class="token attr-name">​</span> <span class="token attr-value">          checked=""属性：只对type="radio"和"checkbox"起作用，设置单选或者多选</span><span class="token attr-name">​</span> <span class="token attr-value">                          按钮是否处于被选中状态</span><span class="token attr-name">​</span> <span class="token attr-value">          disabled=""属性：设置表单中的单项为不可用，灰色状态。</span><span class="token attr-name">​</span> <span class="token attr-value">                           赋值的内容disabled="disabled"</span><span class="token attr-name">​</span> <span class="token attr-value">          maxlength=""属性：只对type="text"和"password"起作用，设置输入</span><span class="token attr-name">​</span> <span class="token attr-value">                            文字的个数</span><span class="token attr-name">​</span> <span class="token attr-value">        二、非input标记系列</span><span class="token attr-name">​</span> <span class="token attr-value">         ①下拉列表框</span>            &lt;select>标记：表示下拉列表框的开始和结束<span class="token attr-name">            &lt;option>标记：下拉列表框中每一个列表项</span> <span class="token attr-value">            </span><span class="token attr-name">​</span> <span class="token attr-value">           属性：</span><span class="token attr-name">​</span> <span class="token attr-value">              name="" :写在&lt;select>标记中</span><span class="token attr-name">​</span> <span class="token attr-value">              value="":写在&lt;option>标记中</span><span class="token attr-name">​</span> <span class="token attr-value">              selected="":设置下拉列表框默认选择的列表项</span><span class="token attr-name">​</span> <span class="token attr-value">                          selected="selected"</span><span class="token attr-name">​</span> <span class="token attr-value">              size=""设置列表框中显示的选项数量</span><span class="token attr-name">​</span> <span class="token attr-value">         ②多行文本域</span>            &lt;textarea>标记<span class="token attr-name">​</span> <span class="token attr-value">             属性：</span><span class="token attr-name">​</span> <span class="token attr-value">               name=""：</span><span class="token attr-name">​</span> <span class="token attr-value">               cols="":设置列数（宽度）</span><span class="token attr-name">​</span> <span class="token attr-value">               rows="":设置行数（高度）</span><span class="token attr-name">​</span> <span class="token attr-value">               disabled=""设置不可应</span><span class="token attr-name">​</span> <span class="token attr-value">             CSS样式：设置多行文本域的大小不可调节</span><span class="token attr-name">​</span> <span class="token attr-value">               sytle=""    resize:none大小不可调节</span><span class="token attr-name">​</span> <span class="token attr-value">                           color:red  字体颜色为红色</span></code></pre><h4 id="4-HTML5"><a href="#4-HTML5" class="headerlink" title="4 HTML5"></a>4 HTML5</h4><p>  在HTML4版本上提供了更多，功能更加强大的标签，H5可以充分满足Web应用多元化的需求，通过使用H5，开发人员<br>  可以很轻松地在网页中实现音频、视频的嵌入，动画效果，表单自动验证等。<br>  如果不用H5新增的这些强大标签，要实现上述那些功能，需要第三方插件或者JavaScript，或者大量代码才能实现。<br>  H5对音频，视频，地理定位等功能的良好支持，直接决定了在移动设备的Web应用，和游戏方面。</p><h6 id="4-1-检查浏览器对HTML5支持"><a href="#4-1-检查浏览器对HTML5支持" class="headerlink" title="4.1 检查浏览器对HTML5支持"></a>4.1 检查浏览器对HTML5支持</h6><p>​      浏览器是否支持<canvas>标记，那就支持HTML5</canvas></p><h6 id="4-2-HTML5页面的结构"><a href="#4-2-HTML5页面的结构" class="headerlink" title="4.2 HTML5页面的结构"></a>4.2 HTML5页面的结构</h6><p>​      相对于HTML4比，语法结构更加简便了。<br>​      （如：版本信息，meta标记等）</p><h4 id="5、HTML5的表单"><a href="#5、HTML5的表单" class="headerlink" title="5、HTML5的表单"></a>5、HTML5的表单</h4><pre class=" language-properties"><code class="language-properties">   &lt;fieldset>标记：可以将表单中的内容分组   &lt;legend>标记：分组后的表单定义标题</code></pre><p>   5.1 新的input标记中的类型</p><h5 id="1）type-”email”类型-输入框，该输入框用于输入电子邮件地址。"><a href="#1）type-”email”类型-输入框，该输入框用于输入电子邮件地址。" class="headerlink" title="1）type=”email”类型   输入框，该输入框用于输入电子邮件地址。"></a>1）type=”email”类型   输入框，该输入框用于输入电子邮件地址。</h5><p>​                             如果在输入框输入的内容不符合电子邮件的格式，<br>​                             提交表单时会给出错误提示<br>​           multiple=””属性：如果值为true，该输入框允许用户输入多个电子邮箱，用<br>​                            逗号隔开<br>​      </p><h5 id="2）日期时间类型"><a href="#2）日期时间类型" class="headerlink" title="2）日期时间类型"></a>2）日期时间类型</h5><p>​    </p><pre class=" language-css"><code class="language-css">  H<span class="token number">4</span>中通常通过第三方JavaScript插件来提供日期输入界面      H<span class="token number">5</span>中定义如下类型就可在页面中生成一个日期时间类型的输入框      type=<span class="token string">"time"</span>        时间      type=<span class="token string">"datetime"</span>      type=<span class="token string">"datetime-local"</span>      type=<span class="token string">"date"</span>      日期/天      type=<span class="token string">"week"</span>      星期      type=<span class="token string">"month"</span>     月份</code></pre><h5 id="3）range类型"><a href="#3）range类型" class="headerlink" title="3）range类型"></a>3）range类型</h5><p>​    </p><pre class=" language-css"><code class="language-css">   在页面中生成一个滑块，通过移动该滑块，选择值       type=<span class="token string">"range"</span>       属性：min=<span class="token string">""</span>  设置滑块的最小值             max=<span class="token string">""</span>  设置滑块的最大值</code></pre><h5 id="4）search类型"><a href="#4）search类型" class="headerlink" title="4）search类型"></a>4）search类型</h5><p>​     在H5中，当一个input标记的类型设置为search时，该输入框用于输出查询的关键字<br>​     ​     说明：search类型的input标记和text类型的input标记相似，可以正常接收输入<br>​           的字符串信息。<br>​           但是也有区别，区别是search类型input标记，在输入内容后显示叉号，点击<br>​           叉号会清空输入的内容。</p><h5 id="5）number类型"><a href="#5）number类型" class="headerlink" title="5）number类型"></a>5）number类型</h5><p>​      是一个数字类型的文本输入控件。number类型的输入框只允许输入数字类型的内容</p><h5 id="6）url类型"><a href="#6）url类型" class="headerlink" title="6）url类型"></a>6）url类型</h5><p>​      生成一个只允许输入网址格式的输入框</p><h4 id="5-2-H5中新增的input标记的属性"><a href="#5-2-H5中新增的input标记的属性" class="headerlink" title="5.2 H5中新增的input标记的属性"></a>5.2 H5中新增的input标记的属性</h4><h5 id="1）autofocus-””属性"><a href="#1）autofocus-””属性" class="headerlink" title="1）autofocus=””属性"></a>1）autofocus=””属性</h5><p>​        </p><pre class=" language-properties"><code class="language-properties">  该属性主要用于设置在页面加载完毕后，页面中控件是否自动获取焦点。          所有的input标记都支持autofocus属性，属性的值为true，自动获得焦点，          如果值为false，不自动获取焦点（浏览器兼容问题，不写）</code></pre><h5 id="2）pattern-””属性"><a href="#2）pattern-””属性" class="headerlink" title="2）pattern=””属性"></a>2）pattern=””属性</h5><pre class=" language-properties"><code class="language-properties">  该属性主要用于设置正则表达式，以便对输入的内容进行自定义验证。<span class="token attr-name">     正则表达式语法：以^开始</span> <span class="token attr-value"> 以$结束</span><span class="token attr-name">-</span> <span class="token attr-value">表示匹配零次到多次</span><span class="token attr-name">-</span> <span class="token attr-value">表示匹配一次到多次（至少有一次）</span><span class="token attr-name">  ​</span> <span class="token attr-value">                   []中括号表示匹配括号中一个字符 范围描述</span>  例子：[0-9a-zA-Z]<span class="token attr-name">  ​</span> <span class="token attr-value">                   {}大括号用于限定匹配次数</span>  例如{n}表示匹配n个字符<span class="token attr-name">  ​</span> <span class="token attr-value">   {n,}表示至少匹配n个字符，n到多个</span><span class="token attr-name">  ​</span> <span class="token attr-value">   {n,m}表示至少n个，做多m个。 n到m个,范围</span></code></pre><h5 id="3）placeholder属性"><a href="#3）placeholder属性" class="headerlink" title="3）placeholder属性"></a>3）placeholder属性</h5><pre class=" language-properties"><code class="language-properties">    该属性用于设置输入框中默认显示的内容。     当在输入框中输入内容后，该提示内容消失；当清空输入框输入的内容时，     该提示内容又显示了。</code></pre><h5 id="4）required属性"><a href="#4）required属性" class="headerlink" title="4）required属性"></a>4）required属性</h5><pre class=" language-properties"><code class="language-properties">  该属性主要用于设置输入框是否必须输入信息（检测是否为空）     如果required的值为true，提交表单时输入框不允许为空     如果required的值为false，提交表单时输入框允许为空</code></pre><p>​        </p><h5 id="5）min属性和max属性"><a href="#5）min属性和max属性" class="headerlink" title="5）min属性和max属性"></a>5）min属性和max属性</h5><p>​      </p><pre class=" language-properties"><code class="language-properties">这两个属性主要用于数值类型或者日期类型的input标记      用于限制输入框所能输入的数值范围</code></pre><h5 id="6）step属性"><a href="#6）step属性" class="headerlink" title="6）step属性"></a>6）step属性</h5><pre class=" language-properties"><code class="language-properties">   该属性主要用于数值型或日期类型的input标记，用于设置每次输入框内数值     的增加或减小的变化量。</code></pre><h5 id="7）novalidate属性"><a href="#7）novalidate属性" class="headerlink" title="7）novalidate属性"></a>7）novalidate属性</h5><pre class=" language-properties"><code class="language-properties">   该属性用于表单设置不验证<span class="token attr-name">      novalidate</span><span class="token punctuation">=</span><span class="token attr-value">"true"</span></code></pre><h4 id="6-JavaScript技术"><a href="#6-JavaScript技术" class="headerlink" title="6 JavaScript技术"></a>6 JavaScript技术</h4><p>  互联网开发     Browser(浏览器)      /    Server(服务器)<br>             (html css JavaScript)        Servlet技术 SSH M框架等技术</p><h5 id="1）概念："><a href="#1）概念：" class="headerlink" title="1）概念："></a>1）概念：</h5><p>​     JavaScript是一种在浏览器端运行的脚本语言，有自己的语法，JavaScript是写在html页面中。</p><h5 id="2）功能："><a href="#2）功能：" class="headerlink" title="2）功能："></a>2）功能：</h5><p>​     （1）数据验证<br>​     （2）动画效果<br>​     （3）浏览器的版本，类型等<br>   （说明：JavaScript实现的任何功能都是在函数里完成的）</p><h5 id="3）体验神奇的JavaScript"><a href="#3）体验神奇的JavaScript" class="headerlink" title="3）体验神奇的JavaScript"></a>3）体验神奇的JavaScript</h5><p>​    （1）直接嵌入式写法<br>​         将JavaScript代码写在html里的</p><p>​     （2）文件调用式写法<br>​     将JavaScript代码写在.js文件里，在html页面中引入.js文件</p><h5 id="4）获取标签对象"><a href="#4）获取标签对象" class="headerlink" title="4）获取标签对象"></a>4）获取标签对象</h5><p>​     document是JS中提供的内置对象<br>​     document.getElementById();  根据id的值获取body体中的标记</p><pre class=" language-javascript"><code class="language-javascript"> 声明变量，js是一种弱类型的语言，声明变量统一用<span class="token keyword">var</span>类型 java<span class="token punctuation">:</span>   int age<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>         double d<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span>         char c<span class="token operator">=</span><span class="token string">'男'</span><span class="token punctuation">;</span>         String name<span class="token operator">=</span><span class="token string">"张三"</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> javascript： <span class="token keyword">var</span> age<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>               <span class="token keyword">var</span> d<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span>              <span class="token keyword">var</span> c<span class="token operator">=</span><span class="token string">'男'</span><span class="token punctuation">;</span>              <span class="token keyword">var</span> name<span class="token operator">=</span><span class="token string">"张三"</span><span class="token punctuation">;</span>           <span class="token function">alert</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Web开发–&gt;互联网开发–&gt;Browser/Server<br>Web开发基础<br>  HTML5         – 页面的内容（<a><img><table><form><b>…  ）<br>  CSS           – 美化页面  style=””添加样式<br>  JavaScript    – 页面端动态效果（数据验证，动态效果）</b></form></table></a></p><p>JavaScript</p><h5 id="1-写法"><a href="#1-写法" class="headerlink" title="1)写法"></a>1)写法</h5><p>  （1）直接嵌入式写法<br>  （2）文件调用式写法</p><h5 id="2）获取标签对象"><a href="#2）获取标签对象" class="headerlink" title="2）获取标签对象"></a>2）获取标签对象</h5><p>​    document.getElementById() </p><pre class=" language-css"><code class="language-css">xx<span class="token number">.</span>style        获取css样式xx<span class="token number">.</span>value        获取具有value属性标记的值xx<span class="token number">.</span>innerHTML    获取没有value鼠标标记的值（&lt;div> &lt;span> &lt;h<span class="token number">1</span>> &lt;p><span class="token number">..</span>） </code></pre><h4 id="7-HTML5关于多媒体的应用"><a href="#7-HTML5关于多媒体的应用" class="headerlink" title="7 HTML5关于多媒体的应用"></a>7 HTML5关于多媒体的应用</h4><p>  HTML在诞生的时候，完全是静态的世界。<br>  HTML4只能通过第三方插件（JavaScript jquery等），能够在页面中支持音频、视频等<br>  HTML5，只需要浏览器是支持HTML5技术的，就可以不借助于任何的第三方插件，直接用标记实现音频，视频。</p><h5 id="7-1）视频"><a href="#7-1）视频" class="headerlink" title="7.1）视频"></a>7.1）视频</h5><pre class=" language-css"><code class="language-css">       &lt;video>标记是用于显示视频的​            属性： src=<span class="token string">""</span> 将要播放视频的路径/名称          autoplay=<span class="token string">""</span> 在页面加载完毕后是否自动播放          width=<span class="token string">""</span>  height=<span class="token string">""</span> 设置大小，只适用于视频&lt;video>标记          controls=<span class="token string">""</span> 该属性用于在页面播放器面板上，显示控制按钮工具栏          poster=<span class="token string">""</span> 在点击视频播放之前，显示的内容          （注意：去掉autoplay=<span class="token string">""</span>属性。如果不去掉，页面加载完直接自动           播放视频，看不到播放前的内容了）</code></pre><h5 id="7-2）音频"><a href="#7-2）音频" class="headerlink" title="7.2）音频"></a>7.2）音频</h5><pre><code>   &lt;audio&gt;标记是用于显示音频的</code></pre><pre class=" language-css"><code class="language-css">   属性：src=<span class="token string">""</span>          autoplay=<span class="token string">""</span>          controls=<span class="token string">""</span></code></pre><h5 id="7-3）error属性"><a href="#7-3）error属性" class="headerlink" title="7.3）error属性"></a>7.3）error属性</h5><pre class=" language-css"><code class="language-css">多媒体在加载读取的时候如果出现了错误，用error提示错误 （onclick=<span class="token string">""</span> ondblclick=<span class="token string">""</span> onmouseover=<span class="token string">""</span> onmouseout=<span class="token string">""</span>）  事件监听  onerror=<span class="token string">""</span> 监听多媒体播放中出现的错误  error<span class="token number">.</span>code获得错误代码号   如果代码号为<span class="token number">4</span>，是视频播放的格式不正确</code></pre><h5 id="7-4）networkState属性"><a href="#7-4）networkState属性" class="headerlink" title="7.4）networkState属性"></a>7.4）networkState属性</h5><pre class=" language-css"><code class="language-css">   该属性用于返回加载媒体文件的网络状态事件监听   onprogress=<span class="token string">""</span> 浏览器在加载视频/音频时触发的事件监听video<span class="token number">.</span>networkState属性的返回值</code></pre><h6 id="1）等于1-表示媒体加载成功，等待播放请求"><a href="#1）等于1-表示媒体加载成功，等待播放请求" class="headerlink" title="1）等于1  表示媒体加载成功，等待播放请求"></a>1）等于1  表示媒体加载成功，等待播放请求</h6><h6 id="2）等于2-表示正在加载媒体信息"><a href="#2）等于2-表示正在加载媒体信息" class="headerlink" title="2）等于2  表示正在加载媒体信息"></a>2）等于2  表示正在加载媒体信息</h6><h6 id="7-5）H5中多媒体播放的方法"><a href="#7-5）H5中多媒体播放的方法" class="headerlink" title="7.5）H5中多媒体播放的方法"></a>7.5）H5中多媒体播放的方法</h6><p>​      </p><pre class=" language-html"><code class="language-html">load()方法：该方法用于重新加载待播放的媒体文件。      play()方法：该方法用于播放媒体文件      pause()方法：该方法用于暂停播放的媒体文件</code></pre><h6 id="7-6）H5中多媒体的事件"><a href="#7-6）H5中多媒体的事件" class="headerlink" title="7.6）H5中多媒体的事件"></a>7.6）H5中多媒体的事件</h6><p>​      </p><pre class=" language-css"><code class="language-css">onerror=<span class="token string">""</span>       该事件监听多媒体播放中出现的错误      onprogress=<span class="token string">""</span>    该事件监听浏览器在加载多媒体时的触发      ontimeupdate=<span class="token string">""</span>  当前播放时间改变，正常播放、快进、拖动播放进度条都会                       触发该事件       currentTime获取已经播放的时长       duration   获取总时长       Math<span class="token number">.</span><span class="token function">floor</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>  取小于或者等于参数的最大整数</code></pre><p>​       </p><h4 id="8-HTML5中的图像和动画"><a href="#8-HTML5中的图像和动画" class="headerlink" title="8 HTML5中的图像和动画"></a>8 HTML5中的图像和动画</h4><h5 id="一、图像"><a href="#一、图像" class="headerlink" title="一、图像"></a>一、图像</h5><pre class=" language-css"><code class="language-css">  H<span class="token number">5</span>中实现了绘画操作，主要是依赖&lt;canvas>标记以及canvas相关的属性和方法  &lt;canvas>从字面上理解是画布的意思，在页面中就相当于在网页中添加了一块画布    属性：sytle=<span class="token string">""</span> 添加css样式，给画布添加边框，画布的背景色          width=<span class="token string">""</span>          height=<span class="token string">""</span> 设置画布区域的大小</code></pre><h5 id="8-1-一个简单的canvas画图实例"><a href="#8-1-一个简单的canvas画图实例" class="headerlink" title="8.1 一个简单的canvas画图实例"></a>8.1 一个简单的canvas画图实例</h5><p>​       （在画布中画一个矩形）</p><pre class=" language-css"><code class="language-css">  <span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">"2d"</span><span class="token punctuation">)</span>   ---> 获得<span class="token number">2</span>d类型的画笔，该画笔画平面图形    <span class="token function">strokeRect</span><span class="token punctuation">(</span>x,y,width,height<span class="token punctuation">)</span> -->画一个矩形</code></pre><h5 id="8-2-使用路径画图"><a href="#8-2-使用路径画图" class="headerlink" title="8.2 使用路径画图"></a>8.2 使用路径画图</h5><p>​       H5中路径是绘图的基础，使用路径画图主要是绘制一些基本的线条、曲线等。</p><h6 id="（1）使用moveTo、lineTo画线"><a href="#（1）使用moveTo、lineTo画线" class="headerlink" title="（1）使用moveTo、lineTo画线"></a>（1）使用moveTo、lineTo画线</h6><pre class=" language-css"><code class="language-css">    <span class="token function">moveTo</span><span class="token punctuation">(</span>x,y<span class="token punctuation">)</span>   绘制直线的起始坐标​       <span class="token function">lineTo</span><span class="token punctuation">(</span>x,y<span class="token punctuation">)</span>   结合moveTo一起使用，绘制直线的终点坐标​       <span class="token function">stroke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      结合moveTo和lineTo一起使用，该方法是将定义好的轨迹在画布上绘制并展示</code></pre><h6 id="（2）使用arc方法画弧形"><a href="#（2）使用arc方法画弧形" class="headerlink" title="（2）使用arc方法画弧形"></a>（2）使用arc方法画弧形</h6><pre class=" language-css"><code class="language-css">     <span class="token function">arc</span><span class="token punctuation">(</span>参数<span class="token number">1</span>，参数<span class="token number">2</span>，参数<span class="token number">3</span>，参数<span class="token number">4</span>，参数<span class="token number">5</span>，参数<span class="token number">6</span><span class="token punctuation">)</span>​      参数<span class="token number">1</span>：表示绘制弧形曲线圆心的横坐标​      参数<span class="token number">2</span>：表示绘制弧形曲线圆心的纵坐标​      参数<span class="token number">3</span>：表示绘制弧形曲线的半径​      参数<span class="token number">4</span>：表示绘制弧形曲线的开始弧度​      参数<span class="token number">5</span>：表示绘制弧形曲线的结束弧度​               弧度=（Math<span class="token number">.</span>PI/<span class="token number">180</span>）*度​               Math<span class="token number">.</span>PI=<span class="token number">3.141592653589793</span>​      参数<span class="token number">6</span>：表示绘制弧形曲线的方向，该参数为布尔类型的值；​                如果为true时，按照逆时针方向绘制弧形​                如果为false，按照顺时针方向绘制弧形​      <span class="token function">stroke</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  该方法按照设定好的轨迹在画布上绘制并展示出来​                所以arc方法使用后，记得使用stroke方法。</code></pre><h5 id="8-3-图形操作"><a href="#8-3-图形操作" class="headerlink" title="8.3 图形操作"></a>8.3 图形操作</h5><h6 id="1）图形样式的设置"><a href="#1）图形样式的设置" class="headerlink" title="1）图形样式的设置"></a><strong>1）图形样式的设置</strong></h6><pre class=" language-css"><code class="language-css">fillStyle=<span class="token string">""</span>属性： 设置画笔的样式（css样式，一个图案，一个渐变）   <span class="token function">fillRect</span><span class="token punctuation">(</span>x,y,width,height<span class="token punctuation">)</span>方法：填充一个矩形（矩形实心）​                                                                                                                                                  strokeStyle=<span class="token string">""</span>属性<span class="token punctuation">:</span>和fillStyle用法相同   <span class="token function">strokeRect</span><span class="token punctuation">(</span>x,y,width,height<span class="token punctuation">)</span>方法：画一个矩形（矩形空心）   <span class="token function">clearRect</span><span class="token punctuation">(</span>x,y,width,height<span class="token punctuation">)</span>方法：清除指定矩形区域</code></pre><h5 id="2）渐变图形"><a href="#2）渐变图形" class="headerlink" title="2）渐变图形"></a>2）渐变图形</h5><p>   渐变在网页设计中是经常用到的一种技术手段，指的是图形填充颜色从一种颜色逐渐的转变为另一种颜色<br>   HTML5中实现渐变的两种方式：线性渐变和径向渐变。</p><h6 id="（1）线性渐变"><a href="#（1）线性渐变" class="headerlink" title="（1）线性渐变"></a>（1）线性渐变</h6><p>​      </p><pre class=" language-css"><code class="language-css">  指的是点到点之间的渐变。        在HTML<span class="token number">5</span>中通过createLinearGradient方法实现的。        <span class="token function">createLinearGradient</span><span class="token punctuation">(</span>参数<span class="token number">1</span>，参数<span class="token number">2</span>，参数<span class="token number">3</span>，参数<span class="token number">4</span><span class="token punctuation">)</span>            参数<span class="token number">1</span>：渐变起始点的横坐标            参数<span class="token number">2</span>：渐变起始点的纵坐标            参数<span class="token number">3</span>：渐变终止点的横坐标            参数<span class="token number">4</span>：渐变终止点的纵坐标         <span class="token function">addColorStop</span><span class="token punctuation">(</span>参数<span class="token number">1</span>，参数<span class="token number">2</span><span class="token punctuation">)</span>设置渐变颜色及渐变度的方法            参数<span class="token number">1</span>：该参数是一个浮点类型的值，范围<span class="token number">0.0</span>到<span class="token number">1.0</span>之间，表示渐变的开始点和结束点                   的一部分。参数<span class="token number">1</span>的值为<span class="token number">0</span>对应开始点，如果为<span class="token number">1.0</span>，对应的是结束点                   （<span class="token number">0.0</span>对应上述方法的参数<span class="token number">1</span>和参数<span class="token number">2</span>                     <span class="token number">1.0</span>对应上述方法的参数<span class="token number">3</span>和参数<span class="token number">4</span>                    ）             参数<span class="token number">2</span>：渐变使用的颜色</code></pre><h6 id="（2）径向渐变"><a href="#（2）径向渐变" class="headerlink" title="（2）径向渐变"></a>（2）径向渐变</h6><p>​    </p><pre class=" language-css"><code class="language-css">    指的是以圆心为起点，沿圆形半径方向向外扩散方式逐渐改变颜色                       <span class="token function">createRadialGradient</span><span class="token punctuation">(</span>参数<span class="token number">1</span>，参数<span class="token number">2</span>，参数<span class="token number">3</span>，参数<span class="token number">4</span>，参数<span class="token number">5</span>，参数<span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        参数<span class="token number">1</span>：渐变开始圆的圆心横坐标        参数<span class="token number">2</span>：渐变开始圆的圆心纵坐标        参数<span class="token number">3</span>：渐变开始圆的半径        参数<span class="token number">4</span>：渐变结束圆的圆心横坐标        参数<span class="token number">5</span>：渐变结束圆的圆心纵坐标        参数<span class="token number">6</span>：渐变结束圆的半径</code></pre><h6 id="3）图形坐标的变换"><a href="#3）图形坐标的变换" class="headerlink" title="3）图形坐标的变换"></a>3）图形坐标的变换</h6><p>   <strong>（1）坐标平移</strong> </p><pre class=" language-css"><code class="language-css">   指的是将默认坐标系的原点，沿x轴方向或y轴方向移动指定单位的长度。        <span class="token function">translate</span><span class="token punctuation">(</span>x,y<span class="token punctuation">)</span>        参数x：为沿x轴方向位移的长度        参数y：为沿y轴方向位移的长度</code></pre><p>   <strong>（2）坐标放大</strong></p><pre class=" language-css"><code class="language-css"> 指的是将图像沿x轴方向或者y轴方向放大的倍数        <span class="token function">scale</span><span class="token punctuation">(</span>x,y<span class="token punctuation">)</span><span class="token punctuation">;</span>        参数x：沿x轴方向放大的倍数        参数y：沿y轴方向放大的倍数​        注意：使用scale方法，如果参数值是大于<span class="token number">1</span>的图形将被放大，如果参数值​              是小于<span class="token number">1</span>的图形将被缩小</code></pre><p>   <strong>（3）坐标旋转</strong></p><pre class=" language-css"><code class="language-css">   指的是以原点为中心，将图形旋转指定的角度。        <span class="token function">rotate</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span>        参数angle表示旋转的弧度，angle如果为正值，图形按照顺时针旋转        如果angle的值为负值，图形按照逆时针旋转​       弧度=<span class="token punctuation">(</span>Math<span class="token number">.</span>PI/<span class="token number">180</span><span class="token punctuation">)</span>*度</code></pre><p>   <strong>4）绘制图片</strong></p><pre class=" language-css"><code class="language-css">  <span class="token function">drawImage</span><span class="token punctuation">(</span>参数<span class="token number">1</span>,<span class="token number">2</span>,<span class="token number">3</span><span class="token punctuation">)</span> 直接绘制图片          参数<span class="token number">1</span>：哪张图片          参数<span class="token number">2</span>和<span class="token number">3</span>：将图片画在画布上的坐标位置  <span class="token function">drawImage</span><span class="token punctuation">(</span>参数<span class="token number">1</span>,<span class="token number">2</span>,<span class="token number">3</span>,<span class="token number">4</span>,<span class="token number">5</span><span class="token punctuation">)</span>  绘制缩放图片     参数<span class="token number">1</span>：哪张图片     参数<span class="token number">2</span>和<span class="token number">3</span>：将图片画在画布上的坐标位置     参数<span class="token number">4</span>和<span class="token number">5</span>：将图片画在画布上的宽度和高度  <span class="token function">drawImage</span><span class="token punctuation">(</span>参数<span class="token number">1</span>,<span class="token number">2</span>,<span class="token number">3</span>,<span class="token number">4</span>,<span class="token number">5</span>,<span class="token number">6</span>,<span class="token number">7</span>,<span class="token number">8</span>,<span class="token number">9</span><span class="token punctuation">)</span>     参数<span class="token number">1</span>：哪张图片     参数<span class="token number">2</span>和<span class="token number">3</span>：图片被绘制部分的坐标     参数<span class="token number">4</span>和<span class="token number">5</span>：图片被绘制部分的宽度和高度​     参数<span class="token number">6</span>和<span class="token number">7</span>：将图片画在画布上的坐标位置​     参数<span class="token number">8</span>和<span class="token number">9</span>：将图片画在画布上的宽度和高度</code></pre><p>   <strong>5）绘制文字</strong></p><pre class=" language-scss"><code class="language-scss"> <span class="token function">fillText</span><span class="token punctuation">(</span><span class="token string">""</span>,x,y<span class="token punctuation">)</span>      <span class="token function">strokeText</span><span class="token punctuation">(</span><span class="token string">""</span>,x,y<span class="token punctuation">)</span></code></pre><p>   <strong>6）制作动画</strong></p><pre class=" language-scss"><code class="language-scss"><span class="token function">setInterval</span><span class="token punctuation">(</span>参数<span class="token number">1</span>，参数<span class="token number">2</span><span class="token punctuation">)</span>      参数<span class="token number">1</span>：设置要执行的绘图函数      参数<span class="token number">2</span>：设置时间间隔，单位毫秒</code></pre><p>  功能：按照设置的时间间隔，反复执行参数1中的函数</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql数据库常见命令</title>
      <link href="/2019/03/27/2018-03-28-mysql-shu-ju-ku-chang-yong-ming-ling/"/>
      <url>/2019/03/27/2018-03-28-mysql-shu-ju-ku-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>1.更改root密码</p><pre class=" language-mysql"><code class="language-mysql">mysqladmin -uroot password 'yourpassword'</code></pre><p>2.远程登陆mysql服务器</p><pre class=" language-mysql"><code class="language-mysql">mysql -uroot -p password 自己的代码</code></pre><p>3.查询数据库</p><pre class=" language-mysql"><code class="language-mysql">show databases;</code></pre><p>4.进入某个数据库</p><pre class=" language-mysql"><code class="language-mysql">use databasename;</code></pre><p>5.列出数据库中的表</p><pre class=" language-mysql"><code class="language-mysql">show tables;</code></pre><p>6.查看某个表全部字段</p><p>6.查看某个表全部字段</p><pre class=" language-mysql"><code class="language-mysql">desc slow_log;show create table slow_log\G; （不仅可以显示表信息，还可以显示建表语句）</code></pre><p>7.查看当前用户</p><pre class=" language-mysql"><code class="language-mysql">select user();</code></pre><p>8.查看当前所在数据库</p><pre class=" language-mysql"><code class="language-mysql">mysqlselect database();</code></pre><p>9.创建新数据库（可以指定字符集）</p><pre class=" language-mysql"><code class="language-mysql">create database db1 charset utf8;</code></pre><p>10.创建新表</p><pre class=" language-mysql"><code class="language-mysql">create table t1 (`id` int(4), `name` char(40));</code></pre><p>11.查看数据库版本</p><pre class=" language-mysql"><code class="language-mysql">select version();</code></pre><p>12.查看数据库状态</p><pre class=" language-mysql"><code class="language-mysql">show status;         当前会话状态show global status;  全局数据库状态show slave status\G;   查看主从数据库状态信息</code></pre><p>13.查询数据库参数</p><pre><code>show variables;</code></pre><p>14.修改数据库参数</p><p>14.修改数据库参数</p><pre class=" language-mysql"><code class="language-mysql">show variables like 'max_connect%';set global max_connect_errors = 1000;（重启数据库会失效，要在配置文件中修改）</code></pre><p>15.查看当前数据库队列</p><pre class=" language-mysql"><code class="language-mysql">show processlist;mysql</code></pre><p>16.创建普通用户并授权给某个数据库</p><pre class=" language-mysql"><code class="language-mysql">grant all on databasename.* to 'user1'@'localhost' identified by '123456';</code></pre><p>17.查询表数据</p><pre class=" language-mysql"><code class="language-mysql">select * from mysql.db;           //查询该表中的所有字段select count(*) from mysql.user;  //count(*)表示表中有多少行select db,user  from mysql.db;    //查询表中的多个字段select * from mysql.db where host like '10.0.%';在查询语句中可以使用万能匹配 “%”</code></pre><p>18.插入一行数据</p><pre class=" language-mysql"><code class="language-mysql">insert into db1.t1 values (1, 'abc');</code></pre><p>19.更改表的某一行数据</p><pre class=" language-mysql"><code class="language-mysql">update db1.t1 set name='aaa' where id=1;</code></pre><p>20.清空表数据</p><pre class=" language-mysql"><code class="language-mysql">truncate table db1.t1;</code></pre><p>21.删除表</p><pre class=" language-mysql"><code class="language-mysql">drop table db1.t1;</code></pre><p>22.清空数据库中的所有表（数据库名是eab12）</p><pre class=" language-mysql"><code class="language-mysql">mysql -N -s information_schema -e "SELECT CONCAT('TRUNCATE TABLE ',TABLE_NAME,';') FROM TABLES WHERE TABLE_SCHEMA='eab12'" | mysql -f eab12</code></pre><p>23.删除数据库</p><pre class=" language-mysql"><code class="language-mysql">drop database db1;</code></pre><p>24.数据库备份</p><pre class=" language-mysql"><code class="language-mysql">mysqldump  -uroot -p'yourpassword' mysql >/tmp/mysql.sql</code></pre><p>25.数据库恢复</p><pre class=" language-mysql"><code class="language-mysql">mysql -uroot -p'yourpassword' mysql </tmp/mysql.sql</code></pre><p>26.新建普通用户</p><pre class=" language-mysql"><code class="language-mysql">CREATE USER name IDENTIFIED BY 'ssapdrow';</code></pre><p>27.更改普通用户密码</p><pre class=" language-mysql"><code class="language-mysql">SET PASSWORD FOR name=PASSWORD('darenzai');</code></pre><p>2.查看name用户权限</p><pre class=" language-mysql"><code class="language-mysql">SHOW GRANTS FOR name;</code></pre><p>29.脚本中执行mysql命令</p><pre class=" language-mysql"><code class="language-mysql">mysql -uuser -ppasswd -e"show databases"echo "show databases"|mysql -uuser -ppassword</code></pre><br>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库时区格式错误</title>
      <link href="/2018/12/01/2019-02-01-shu-ju-ku-shi-qu-ge-shi-cuo-wu/"/>
      <url>/2018/12/01/2019-02-01-shu-ju-ku-shi-qu-ge-shi-cuo-wu/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库时区格式错误（设置数据库时区）"><a href="#数据库时区格式错误（设置数据库时区）" class="headerlink" title="数据库时区格式错误（设置数据库时区）"></a><em>数据库时区格式错误（设置数据库时区）</em></h3><p><strong>上次网站demo出现莫名其妙的错误上网一查原来是数据库时区错误</strong></p><p><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g25v1higtlj30tc0dbjsw.jpg" alt></p><p>解决办法是设置好 数据库时区</p><p>打开数据库命令行</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g25v37fia0j318g0ntgnk.jpg" alt></p><p>输入MySQL命令</p><pre class=" language-mysql"><code class="language-mysql">set global time_zone = '+8:00';  #将数据库时区设置为东八时区</code></pre><p><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g25v858a9hj30cc046mx2.jpg" alt></p><p>输入命令bug得到解决</p><p><em>注：这个bug在页面上不会显示报错,只有在控制台才能看到错误</em></p><p>bug解决数据正常显示</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g25vbm1xw4j30zo0ftwfo.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的最短路</title>
      <link href="/2018/11/17/2018-04-06-tu-de-zui-duan-lu-wen-ti/"/>
      <url>/2018/11/17/2018-04-06-tu-de-zui-duan-lu-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Dijkstra-算法"><a href="#1-Dijkstra-算法" class="headerlink" title="1.Dijkstra 算法"></a>1.Dijkstra 算法</h3><p>　　首先来看一下 Dijkstra 算法,它不能够处理权值为负的图.本算法的主要步骤:</p><p>　　</p><p>　　1.找出距离起始顶点距离最短的顶点,这里设为顶点nowVertice.</p><p>　　2.遍历所有与顶点nowVertice相邻的顶点nextVertice.如果发现选择nowVertice到达nextVertice的路径后,nextVertice距离起始顶点的距离比当前的距离小.便更新新的距离.如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>currDist<span class="token punctuation">[</span>nextVertice<span class="token punctuation">]</span> <span class="token operator">></span> currDist<span class="token punctuation">[</span>nowVertice<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　　　　　　　　　    <span class="token comment" spellcheck="true">//weight为从nowVertice到nextVertice说需要的权重</span>                currDist<span class="token punctuation">[</span>nextVertice<span class="token punctuation">]</span> <span class="token operator">=</span> currDist<span class="token punctuation">[</span>nowVertice<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>　　　　currDist是一个全局数组,currDist[i]意思就是当前起始顶点到顶点i的距离.</p><p>　　3.将nowVertice从图中删除.</p><p>　　4.重复步骤1,直到所有的顶点都被删除完.</p><p>　　补充,在实现的时候,上面说的删除并不是真的直接从图中把某一顶点删除,这里会使用一个集合来存储所有的顶点,对该集合中的顶点进行删除动作,集合如下.</p><p>List<integer> toBeChecked = new LinkedList&lt;&gt;();　　</integer></p><p>　　和上一篇一样,这里使用一个名为Graph的类来封装查找最短路径的相关内容:</p><p>/**</p><ul><li><p>使用邻接矩阵实现图</p><p></p></li><li><p>深度优先遍历与广度优先遍历</p><p></p></li><li><p>求最短路径:</p><p></p></li><li><ol><li>Dijkstra 算法 <p></p></li></ol></li><li><ol start="2"><li>Ford 算法 <p></p></li></ol></li><li><ol start="3"><li>通用型的纠正标记算法<p></p></li></ol></li><li><p>Created by Henvealf on 16-5-22.<br> */</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Graph</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> racs<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//邻接矩阵</span> <span class="token keyword">private</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> verticeInfo<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//各个点所携带的信息.</span> <span class="token keyword">private</span> <span class="token keyword">int</span> verticeNum<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//顶点的数目,</span> <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visitedCount<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//记录访问</span> <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> currDist<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//最短路径算法中用来记录每个顶点距离起始顶点路径的长度.</span> <span class="token keyword">public</span> <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> racs<span class="token punctuation">,</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> verticeInfo<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>racs<span class="token punctuation">.</span>length <span class="token operator">!=</span> racs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"racs is not a adjacency matrix!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>racs<span class="token punctuation">.</span>length <span class="token operator">!=</span> verticeInfo<span class="token punctuation">.</span>length <span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span> <span class="token punctuation">(</span><span class="token string">"Argument of 2 verticeInfo's length is error!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>racs <span class="token operator">=</span> racs<span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>verticeInfo <span class="token operator">=</span> verticeInfo<span class="token punctuation">;</span>     verticeNum <span class="token operator">=</span> racs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>     visitedCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>verticeNum<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//..........       </span> <span class="token punctuation">}</span></code></pre></li></ul><p> 　　这里是使用的邻接矩阵来表示图,想要使用其他表示方法,自行稍微修改一下便可.下面是实现方法的代码:</p><pre class=" language-java"><code class="language-java"> <span class="token number">1</span> <span class="token comment" spellcheck="true">/** 2      * 使用 Dijkstra算法寻找最短路径 3      * @param first 路径开始的顶点 4      * @return 返回最后的最短路径 5      */</span> <span class="token number">6</span>     <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">dijkstraAlgorithm</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token number">7</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>first <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> first <span class="token operator">>=</span> verticeNum <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token number">8</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span> <span class="token punctuation">(</span><span class="token string">"should between 0 ~ "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>verticeNum <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">9</span>         <span class="token punctuation">}</span><span class="token number">10</span>         <span class="token function">setNumberAsInfinitie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">11</span>         currDist<span class="token punctuation">[</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">12</span>         List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> toBeChecked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">13</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> verticeNum<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">14</span>             toBeChecked<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">15</span>         <span class="token punctuation">}</span><span class="token number">16</span>         <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>toBeChecked<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">17</span>             <span class="token keyword">int</span> nowVertice <span class="token operator">=</span> <span class="token function">findMinCurrDistVerticeAndRemoveFormList</span><span class="token punctuation">(</span>toBeChecked<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">18</span>             <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> verticeNum<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">19</span>                 <span class="token keyword">int</span> nextVertice <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//邻接节点</span><span class="token number">20</span>                 <span class="token keyword">int</span> weight <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//到达邻接节点的权重</span><span class="token number">21</span>                 <span class="token keyword">if</span><span class="token punctuation">(</span>racs<span class="token punctuation">[</span>nowVertice<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//得到邻接顶点</span><span class="token number">22</span>                     <span class="token keyword">if</span><span class="token punctuation">(</span>toBeChecked<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">23</span>                         nextVertice <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token number">24</span>                         weight <span class="token operator">=</span> racs<span class="token punctuation">[</span>nowVertice<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token number">25</span>                     <span class="token punctuation">}</span><span class="token number">26</span>                 <span class="token punctuation">}</span><span class="token number">27</span>                 <span class="token keyword">if</span><span class="token punctuation">(</span>nextVertice <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">28</span>                 <span class="token keyword">if</span><span class="token punctuation">(</span>currDist<span class="token punctuation">[</span>nextVertice<span class="token punctuation">]</span> <span class="token operator">></span> currDist<span class="token punctuation">[</span>nowVertice<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">29</span>                     currDist<span class="token punctuation">[</span>nextVertice<span class="token punctuation">]</span> <span class="token operator">=</span> currDist<span class="token punctuation">[</span>nowVertice<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">;</span><span class="token number">30</span>                 <span class="token punctuation">}</span><span class="token number">31</span>             <span class="token punctuation">}</span><span class="token number">32</span> <span class="token number">33</span>         <span class="token punctuation">}</span><span class="token number">34</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currDist<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">35</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"现在顶点 "</span> <span class="token operator">+</span> verticeInfo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 距离顶点 "</span> <span class="token operator">+</span> verticeInfo<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token operator">+</span> <span class="token string">" 的最短距离为 "</span> <span class="token operator">+</span> currDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">36</span>         <span class="token punctuation">}</span><span class="token number">37</span>         <span class="token keyword">return</span> currDist<span class="token punctuation">;</span><span class="token number">38</span>     <span class="token punctuation">}</span><span class="token number">39</span> 　　<span class="token comment" spellcheck="true">/**40      * 将currDist数组初始化为无穷大41      */</span><span class="token number">42</span>     <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setNumberAsInfinitie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">43</span>         currDist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>verticeNum<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token number">44</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> verticeNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">45</span>             currDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span><span class="token number">46</span>         <span class="token punctuation">}</span><span class="token number">47</span>     <span class="token punctuation">}</span><span class="token number">48</span> <span class="token number">49</span>     <span class="token comment" spellcheck="true">/**50      * 寻找出当前距离起始顶点路径最短的顶点,并将其从toBeCheck中删除51      * @param list52      * @return53      */</span><span class="token number">54</span>     <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findMinCurrDistVerticeAndRemoveFormList</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">55</span>         <span class="token keyword">int</span> num <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">56</span>         <span class="token keyword">int</span> dist <span class="token operator">=</span> currDist<span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token number">57</span>         <span class="token keyword">int</span> listIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">58</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">59</span>             <span class="token keyword">int</span> index <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">60</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>currDist<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">61</span>                 dist <span class="token operator">=</span> currDist<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token number">62</span>                 num <span class="token operator">=</span> index<span class="token punctuation">;</span><span class="token number">63</span>                 listIndex <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token number">64</span>             <span class="token punctuation">}</span><span class="token number">65</span>         <span class="token punctuation">}</span><span class="token number">66</span>         list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>listIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">67</span>         <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token number">68</span>     <span class="token punctuation">}</span></code></pre><h3 id="2-Ford-算法"><a href="#2-Ford-算法" class="headerlink" title="2.Ford 算法"></a>2.Ford 算法</h3><p>　　上面提到Dijkstra算法不能处理有负权值的情况,所以自然就有替代方法:Ford方法.</p><p>　　Ford算法并不会像Dijkstra算法一样去删除顶点,他时按照一定的顺序,来对每个边进行遍历并更新设置最短距离.</p><p>　　比如有一个异常简单的图:</p><p>　　　　a–&gt;b–&gt;c–&gt;d</p><p>　　Ford算法要求我们指定边的遍历顺序,让每条边都能够被走过一次.比如这里我选择的顺序为:b–&gt;c,  a–&gt;b, c–&gt;d.</p><p>　　算法就会根据指定的该顺序,把图中所有的边都访问一次,每访问完一遍就是一次迭代.在访问过程中,和Dijkstra算法相似,回进行如下判断和更新.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>currDist<span class="token punctuation">[</span>now<span class="token punctuation">]</span> <span class="token operator">></span> currDist<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">)</span><span class="token punctuation">{</span>         currDist<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">=</span> currDist<span class="token punctuation">[</span>now<span class="token punctuation">]</span> <span class="token operator">+</span> racs<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>　　然后直到在最后一次迭代中,发现所有的边都不符合上面的判断,算法就结束.</p><p>　　实现代码如下:</p><pre class=" language-java"><code class="language-java"> <span class="token number">1</span> <span class="token comment" spellcheck="true">/** 2      * 使用Ford的方法寻找最短路径 3      * @param first 路径开始的顶点 4      */</span> <span class="token number">5</span>     <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">fordAlgorithm</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token number">6</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>first <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> first <span class="token operator">>=</span> verticeNum <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token number">7</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span> <span class="token punctuation">(</span><span class="token string">"should between 0 ~ "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>verticeNum <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">8</span>         <span class="token punctuation">}</span> <span class="token number">9</span>         <span class="token function">setNumberAsInfinitie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">10</span>         currDist<span class="token punctuation">[</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">11</span>         <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">12</span>             <span class="token keyword">boolean</span> hasLessEdge <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//是否有使currDist更小的边</span><span class="token number">13</span>             <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> s <span class="token operator">&lt;</span> verticeNum<span class="token punctuation">;</span> s <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">14</span>                 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">&lt;</span> verticeNum<span class="token punctuation">;</span> e <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">15</span>                     <span class="token keyword">if</span><span class="token punctuation">(</span>racs<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>e<span class="token punctuation">]</span> <span class="token operator">!=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">16</span>                         <span class="token keyword">int</span> weight <span class="token operator">=</span> <span class="token function">getWeightPreventOverflow</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">17</span>                         <span class="token keyword">if</span><span class="token punctuation">(</span>currDist<span class="token punctuation">[</span>e<span class="token punctuation">]</span> <span class="token operator">></span> currDist<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">18</span>                             hasLessEdge <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token number">19</span>                             currDist<span class="token punctuation">[</span>e<span class="token punctuation">]</span> <span class="token operator">=</span> currDist<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">+</span> racs<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token number">20</span>                         <span class="token punctuation">}</span><span class="token number">21</span>                     <span class="token punctuation">}</span><span class="token number">22</span>                 <span class="token punctuation">}</span><span class="token number">23</span>             <span class="token punctuation">}</span><span class="token number">24</span>             <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>hasLessEdge<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token number">25</span>         <span class="token punctuation">}</span><span class="token number">26</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currDist<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">27</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"现在顶点 "</span> <span class="token operator">+</span> verticeInfo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 距离顶点 "</span> <span class="token operator">+</span> verticeInfo<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token operator">+</span> <span class="token string">" 的最短距离为 "</span> <span class="token operator">+</span> currDist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">28</span>         <span class="token punctuation">}</span><span class="token number">29</span> <span class="token number">30</span>         <span class="token keyword">return</span> currDist<span class="token punctuation">;</span><span class="token number">31</span>     <span class="token punctuation">}</span><span class="token number">32</span> <span class="token number">33</span>     <span class="token comment" spellcheck="true">/**34      * 处理并获得权重,并且使得到的结果在进行路径长度的加减操作时不会出现溢出35      * @param start36      * @param end37      * @return38      */</span><span class="token number">39</span>     <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getWeightPreventOverflow</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">40</span>         <span class="token keyword">int</span> weight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">41</span>         <span class="token comment" spellcheck="true">//防止加减法溢出</span><span class="token number">42</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>currDist<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">&amp;&amp;</span> racs<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">43</span>             weight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">44</span>         <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>currDist<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> Integer<span class="token punctuation">.</span>MIN_VALUE <span class="token operator">&amp;&amp;</span> racs<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">45</span>             weight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token number">46</span>         <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token number">47</span>             weight <span class="token operator">=</span> racs<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token number">48</span>         <span class="token punctuation">}</span><span class="token number">49</span>         <span class="token keyword">return</span> weight<span class="token punctuation">;</span><span class="token number">50</span>     <span class="token punctuation">}</span></code></pre><p><br> 引用自：<a href="http://www.cnblogs.com/Henvealf/p/5574455.html" target="_blank" rel="noopener">http://www.cnblogs.com/Henvealf/p/5574455.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库总结</title>
      <link href="/2018/11/11/2019-03-24-oracel/"/>
      <url>/2018/11/11/2019-03-24-oracel/</url>
      
        <content type="html"><![CDATA[<p>先来了解几个概念：<br>    <strong>数据(Data)：</strong><br>        数据库中的存储的基本对象。<br>    <strong>数据库(Database):</strong><br>        长期存储在计算机内、有组织、可共享的大量数据的集合。<br>    <strong>数据库管理系统(Database Management System,dbms):</strong><br>        是位于用户和操作系统之间的数据管理软件，科学的组织和存储数据、高效的检索和维护数据<br>    <strong>数据库系统(Database System,dbs):</strong><br>        数据库系统是为适应数据处理的需要而发展起来的一种较为理想的数据处理系统，<br>        也是一个为实际可运行的存储、维护和应用系统提供数据的软件系统，<br>        是存储介质 、处理对象和管理系统的集合体。</p><h1 id="数据库简介"><a href="#数据库简介" class="headerlink" title="数据库简介"></a>数据库简介</h1><ol><li><p><strong>数据库 DataBase</strong><br>数据库是一种软件产品，用于存储数据，管理数据<br>的存储仓库，是有效组织在一起的数据集合。<br><strong>2.常用的数据库软件</strong><br><strong>1）大型数据库</strong></p><pre><code> (1)Oracle  Oracle是甲骨文公司发明的产品 (2)DB2      DB2是IBM公司推出的产品 (3)Sybase  是美国Sybase公司推出的数据库</code></pre><p><strong>2）中型数据库</strong></p><pre><code> （1）Sql Server 微软公司推出,一般使用在.net语言开发上   (2) MySQL属于偏中小型的数据库管理系统。开源免费。08年被Sun公司收购，Sun又被Oracle       收购。体积小，速度快，成本低。</code></pre><p><strong>3）小型数据库</strong></p><pre><code>   Access 微软推出的小型数据库，几乎淘汰。</code></pre></li><li><p><strong>结构化查询语言(Structured Query Language，SQL)</strong><br>SQL语言用来在数据库上执行数据操作、检索及维护所使用的标准语言，<br>是一个综合的、通用的数据库语言。大数据的数据库都使用相同或者相似的语言来操作和维护数据库。<br>SQL语言可以查询数据，操纵数据，定义数据，控制数据，软件开发人员、数据库管理人员都可以通过<br>SQL语言对数据库执行的特定的操作。</p></li><li><p>DBA<br>数据库管理员(DataBase Administrator，DBA），是从事管理和维护数据库管理系统(DBMS)的</p><pre><code>相关工作人员的统称，属于运维工程师的一个分支，主要负责业务数据库从设计、测试到部署交付的全生命周期管理。</code></pre></li><li><p>Table（表）<br>表结构（Table）：<br>表是数据库存储的基本单元，对应于现实世界中的实体对象，比如部门，职员、学生等，<br>表是一个二维结构，由行和列组成，横向为行(Row)，也叫记录(Record)，用来表示实体的数据，<br>比如一个学生的相关信息。纵向为列(Column)，也叫作字段(Filed)，用来表示实体的属性，<br>比如学生的身高、年龄。</p><pre><code>                 学号  姓名  性别  年龄  身高  班级                   1     Li    F     22    173   ..                   2    Wang   M     23    175                  ..    ..    ..    ..     ..   ..</code></pre><p>记录（Record）：</p><pre><code>每个表包含了若干行数据，它们是表的值，表中的一行称为一条记录，所以可以说，表是记录的有限集合。</code></pre><p>字段（Filed）：</p><pre><code>每条记录都由若干个数据项构成，将构成记录的每个数据项称为字段。</code></pre><p>关键字（Key）：</p><pre><code>若表中记录的某一字段或字段组合能作为标识记录，则称该字段或字段组合为候选关键字。若一个表有多个候选关键字，则选定其中一个为主关键字，也称主键。当一个表仅有唯一</code></pre><p>   的一个候选关键字时，该候选关键字就是主关键字，可以用来唯一标识记录行。</p></li><li><h1 id="SQL语言的分类"><a href="#SQL语言的分类" class="headerlink" title="SQL语言的分类"></a>SQL语言的分类</h1><p><strong>1）数据定义语言DDL(Data Definition Language),是SQL语言集中负责数据结构定义与</strong><br>   数据库对象定义的语言，包括：</p><pre><code>create语句                 --   数据库对象的创建alter语句                    --   修改数据库对象drop语句                   --   删除数据库对象truncate语句              --   清除表数据</code></pre><p> <strong>2）数据操纵语言DML（Data Manipulation Language），用户通过它可以实现对数据表的基本</strong></p><pre><code>  操作，包括：增、删、改  insert            --  插入操作  update         --  修改操作  delete          --  删除操作</code></pre><p> <strong>3）数据查询语言DQL(Data Query Language)，用于主要通过它实现对数据的查询操作</strong></p><pre><code>  包括：  select   -- 查询操作</code></pre><p> <strong>4）事务控制语言TCL（Transaction Control Language），用来对DML操作进行确认的</strong></p><pre><code>  包括：   commit    提交数据              rollback    数据回滚              savepoint  保存点</code></pre></li></ol><pre><code>           savepoint是事务内部允许部分rollback的标志符。因为事务中对记录做了修改，           我们可以在事务中创建savepoint来标识不同的点。           如果遇到错误，就可以rollback到不同的点或直接回来事务最开始的点。     </code></pre><p>   。</p><ol start="6"><li><h1 id="Oracle数据库的数据类型"><a href="#Oracle数据库的数据类型" class="headerlink" title="Oracle数据库的数据类型"></a>Oracle数据库的数据类型</h1><p><strong>1）数字</strong></p><pre><code>    number(n)       数字(最长n位) number(3)               number(n,m)   浮点数(总长为n，小数点后为m位)       例如：number(7,2)   99999.99</code></pre><p><strong>2）字符串</strong></p><pre><code>    char(n)       表示定常字符串(方便查询)                      最长放入n个字符，放入的数据如果不够n个字符则补空格，无论如何都占n个                      字符的长度                      char(5)   &#39;abc  &#39;    varchar(n)  表示变长字符串(节省空间)                      最长放入n个字符，放入的数据是几个长度就占多大空间                      varchar(5)   &#39;abc&#39;     varchar2(n)  Oracle自己定义的变长字符串</code></pre><p><strong>3）日期</strong>    </p><pre><code>    date      日期</code></pre></li></ol><ol start="7"><li><h1 id="创建表-对象"><a href="#创建表-对象" class="headerlink" title="创建表  == 对象"></a>创建表  == 对象</h1><h4 id="1）DDL-–-create语句"><a href="#1）DDL-–-create语句" class="headerlink" title="1）DDL  –  create语句"></a>1）DDL  –  create语句</h4><p>​            语法： create table 表名(字段1 类型 , 字段2 类型，…);<br>​      注意：表名的命名规则</p><h6 id="1、必须以字母开头；"><a href="#1、必须以字母开头；" class="headerlink" title="1、必须以字母开头；"></a>1、必须以字母开头；</h6><h6 id="2、不使用汉字的列名和表名；（有可能出现乱码）"><a href="#2、不使用汉字的列名和表名；（有可能出现乱码）" class="headerlink" title="2、不使用汉字的列名和表名；（有可能出现乱码）"></a>2、不使用汉字的列名和表名；（有可能出现乱码）</h6><h6 id="3、表名不能超过30个字符；"><a href="#3、表名不能超过30个字符；" class="headerlink" title="3、表名不能超过30个字符；"></a>3、表名不能超过30个字符；</h6><h6 id="4、表名、列名是自由定义的，包含字母-A-Z，a-z-、数字-0-9-、-、-、-组成；"><a href="#4、表名、列名是自由定义的，包含字母-A-Z，a-z-、数字-0-9-、-、-、-组成；" class="headerlink" title="4、表名、列名是自由定义的，包含字母(A-Z，a-z)、数字(0-9)、_、$、#组成；"></a>4、表名、列名是自由定义的，包含字母(A-Z，a-z)、数字(0-9)、_、$、#组成；</h6><h6 id="5、不能使用保留字：如create、select、char等；"><a href="#5、不能使用保留字：如create、select、char等；" class="headerlink" title="5、不能使用保留字：如create、select、char等；"></a>5、不能使用保留字：如create、select、char等；</h6><h6 id="6、对同一个用户不能使用相同的表名称，对同一表不能使用相同的列名；"><a href="#6、对同一个用户不能使用相同的表名称，对同一表不能使用相同的列名；" class="headerlink" title="6、对同一个用户不能使用相同的表名称，对同一表不能使用相同的列名；"></a>6、对同一个用户不能使用相同的表名称，对同一表不能使用相同的列名；</h6><h6 id="7、所有的SQL语句都是以“-”结尾"><a href="#7、所有的SQL语句都是以“-”结尾" class="headerlink" title="7、所有的SQL语句都是以“;”结尾"></a>7、所有的SQL语句都是以“;”结尾</h6><p>  练习：创建用户表，</p><pre><code>   1）首先咱们先要创建一个.sql文件(可以用咱们的记事本打开)是个脚本文件和咱们的shell程序一样，</code></pre><p>  后缀是.sql，这个也可以是别的，但是以sql为后缀容易辨识和识别。<br>  2）然后输入sql语句。<br>  3）最后执行咱们的sql文件。</p></li></ol><pre class=" language-mysql"><code class="language-mysql">   1.win+R  输入cmd 进入dos窗口   2.登录sqlplus       注：       path>sqlplus 用户名/密码       path>sqlplus system/tarena       输入密码后        输入行显示提示符：  SQL>       此时输入： @+文件物理路径       如：@D:/sql/ch1.sql       提示Done.之后提交事务        commit;     </code></pre><pre><code></code></pre><pre><code>表中的列名由：列名                 数据类型学号id               number(4)密码password         char(4)姓名name             char(20)电话phone            char(20)邮箱email            varchar2(50)</code></pre><p>​      </p><pre class=" language-sql"><code class="language-sql">   <span class="token keyword">drop</span> <span class="token keyword">table</span> user_1<span class="token punctuation">;</span>   <span class="token keyword">create</span> <span class="token keyword">table</span> user_1<span class="token punctuation">(</span>         id number<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         password char<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         name char<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         phone char<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         email varchar2<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>      <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tab<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//查看数据库中的所有表 </span></code></pre><p>   <strong>2）desc语句（description）</strong><br>     语法：  desc 表名;        查看表结构<br>     SQL-&gt;  desc user_1;<br>     <strong>3）default默认值（默认约束）</strong><br>     作用：可以通过default给列指定默认值</p><pre class=" language-sql"><code class="language-sql">   SQL<span class="token operator">-</span><span class="token operator">></span>   <span class="token keyword">create</span> <span class="token keyword">table</span> user_2<span class="token punctuation">(</span>                       id number<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">1001</span><span class="token punctuation">,</span>                       password char<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">'abcd'</span>                  <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre><code> **4）not null约束**所用：非空(not null)是一种约束条件，用于确保字段值不能为空；           默认情况下，任何列都允许有空值；           当某个字段被设置了非空约束条件，这个字段中必须存在有效值；           当执行插入数据操作的时候，必须提供这个列的数据；           当执行更新/修改操作时，不能给这个列的值设置为NULL;</code></pre><pre class=" language-sql"><code class="language-sql">    SQL<span class="token operator">-</span><span class="token operator">></span>    <span class="token keyword">create</span> <span class="token keyword">table</span> user_3<span class="token punctuation">(</span>         id number<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">1001</span><span class="token punctuation">,</span>         password char<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>   –&gt; 1  ‘abcd’       –&gt; 1    ‘abcd’<br>   –&gt;     ‘abcd’       –&gt; 1001  ‘abcd’<br>   –&gt; 1                   –&gt;报错误</p><p>   –&gt; 1  ‘abcd’       –&gt; 1    ‘abcd’<br>   –&gt;     ‘abcd’       –&gt; 1001  ‘abcd’<br>   –&gt; 1                   –&gt;报错误</p><pre><code> **4）not null约束**所用：非空(not null)是一种约束条件，用于确保字段值不能为空；           默认情况下，任何列都允许有空值；           当某个字段被设置了非空约束条件，这个字段中必须存在有效值；           当执行插入数据操作的时候，必须提供这个列的数据；           当执行更新/修改操作时，不能给这个列的值设置为NULL;SQL-&gt;create table user_3(     id number(4) default 1001,     password char(4) not null);</code></pre><p>   –&gt; 1  ‘abcd’       –&gt; 1    ‘abcd’<br>   –&gt;     ‘abcd’       –&gt; 1001  ‘abcd’<br>   –&gt; 1                   –&gt;报错误</p><ol start="8"><li><h1 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a><strong>修改表</strong></h1><p>1）修改表名  – 在建表后如果希望修改表名，可以使用rename语句实现</p><pre><code> 语法：  rename 原表名 to 新表名;  SQL-&gt;   rename user_1 to t_user;</code></pre><p> <strong>2）增加列</strong></p><pre><code>   给表增加列使用  语法：alter table 表名 add(字段1 类型 约束, 字段2 类型 约束...);</code></pre></li></ol><pre class=" language-sql"><code class="language-sql">   SQL<span class="token operator">-</span><span class="token operator">></span>        <span class="token keyword">alter</span> <span class="token keyword">table</span> user_2 <span class="token keyword">add</span><span class="token punctuation">(</span>           name char<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">'zs'</span><span class="token punctuation">,</span>           phone varchar2<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span>       <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>   <strong>3）删除列</strong><br>        使用alter table …drop语句删除不需要的列<br>        语法： alter table 表名 drop(字段1, 字段2, 字段3…);</p><pre class=" language-sql"><code class="language-sql">    SQL<span class="token operator">-</span><span class="token operator">></span>        <span class="token keyword">alter</span> <span class="token keyword">table</span> user_2 <span class="token keyword">drop</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>phone<span class="token punctuation">,</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>   <strong>4）修改列</strong><br>        建表之后，可以改变表中列的数据类型、长度和默认值；<br>        修改仅对以后插入的数据有效；<br>        如果把长度由大改小，不会成功的；<br>        语法： alter table 表名 modify(字段 类型);</p><pre class=" language-sql"><code class="language-sql">   SQL<span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">alter</span> <span class="token keyword">table</span> user_2 <span class="token keyword">modify</span><span class="token punctuation">(</span>id number<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="10-DML语句"><a href="#10-DML语句" class="headerlink" title="10.DML语句"></a>10.DML语句</h1><pre><code> 1）insert语句     给表增加数据     语法：insert into 表名(字段1, 字段2,...) values(值1, 值2,...);     注意：执行DML操作后，需要执行commit语句提交,才算真正的确认了此操作     SQL-&gt;     INSERT INTO T_USER()....     insert into t_user(id, password, name, phone, email)      values(1001, &#39;abc&#39;, &#39;zs&#39;, &#39;138222112&#39;, &#39;a@qq.com&#39;);     commit;     select  *  from  t_user;      查看t_user表中所有列的数据信息     --往表中插入某几个字段     insert into t_user(id, password) values(1002, &#39;cba&#39;);     commit;     --往表中所有的字段都插入数据(表后不用写字段，但是values中必须包含所有字段的值)     insert into t_user values(1003, &#39;1234&#39;, &#39;ww&#39;, &#39;138002212&#39;, &#39;b@qq.com&#39;);     commit;</code></pre><p>   ​<br>         如果插入的列有日期字段，需要考虑日期的格式<br>         默认的日期格式：  ‘DD-MM-YY’  12-3月-19</p><p>   ​     </p><pre class=" language-sql"><code class="language-sql">   <span class="token comment" spellcheck="true">//alter session set nls_language = 'SIMPLIFIED CHINESE';</span>   <span class="token comment" spellcheck="true">//alter session set nls_date_language='SIMPLIFIED CHINESE';</span>   <span class="token comment" spellcheck="true">--ANSI格式</span>   <span class="token comment" spellcheck="true">//设置日期格式</span>   <span class="token comment" spellcheck="true">--alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';</span>   <span class="token keyword">alter</span> <span class="token keyword">session</span> <span class="token keyword">set</span> nls_language <span class="token operator">=</span><span class="token string">'AMERICAN'</span><span class="token punctuation">;</span>   <span class="token keyword">alter</span> <span class="token keyword">session</span> <span class="token keyword">set</span> nls_date_language<span class="token operator">=</span><span class="token string">'AMERICAN'</span><span class="token punctuation">;</span>     可以自定义日期格式，用to_date函数转换为日期类型的数据     SQL<span class="token operator">-</span><span class="token operator">></span>     <span class="token keyword">alter</span> <span class="token keyword">table</span> t_user <span class="token keyword">add</span><span class="token punctuation">(</span>bir <span class="token keyword">date</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">--向数据库表中插入当前日期，系统时间--sysdate</span>     <span class="token keyword">insert</span> <span class="token keyword">into</span> t_user<span class="token punctuation">(</span>id<span class="token punctuation">,</span> bir<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1004</span><span class="token punctuation">,</span> sysdate<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">commit</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">--自定义日期格式  to_date()函数   '2019:3:14'</span>     <span class="token keyword">insert</span> <span class="token keyword">into</span> t_user<span class="token punctuation">(</span>id<span class="token punctuation">,</span> bir<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1005</span><span class="token punctuation">,</span> to_date<span class="token punctuation">(</span><span class="token string">'2019:3:14'</span><span class="token punctuation">,</span><span class="token string">'YYYY:MM:DD'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">commit</span><span class="token punctuation">;</span></code></pre><pre><code> **2）update语句**     更新/修改表中的数据     语法：update 表名 set 字段1=新值1, 字段2=新值2... where 字段=值;     如果没有where条件，则全表的数据都会被更新，务必小心</code></pre><pre class=" language-sql"><code class="language-sql">   SQL<span class="token operator">-</span><span class="token operator">></span>         <span class="token keyword">update</span> t_user <span class="token keyword">set</span> password<span class="token operator">=</span><span class="token string">'999'</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1001</span><span class="token punctuation">;</span>        <span class="token keyword">update</span> t_user <span class="token keyword">set</span> password<span class="token operator">=</span><span class="token string">'666'</span><span class="token punctuation">;</span>        <span class="token keyword">update</span> t_user <span class="token keyword">set</span> password<span class="token operator">=</span><span class="token string">'555'</span><span class="token punctuation">,</span>email<span class="token operator">=</span><span class="token string">'p@qq.com'</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1001</span><span class="token punctuation">;</span></code></pre><pre><code> **3）delete语句**    删除表中的数据    语法： delete from 表名 where 条件;    如果没有where条件，则表中的数据全部删除   SQL-&gt;  delete from t_user where id=1006;</code></pre><pre class=" language-sql"><code class="language-sql">   SQL<span class="token operator">-</span><span class="token operator">></span>   <span class="token keyword">delete</span> <span class="token keyword">from</span> t_user<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">--删除全部的数据</span>   注意：DDL语句中的<span class="token keyword">truncate</span>，也可以清除表中的所有数据              语法： <span class="token keyword">truncate</span> <span class="token keyword">table</span> 表名<span class="token punctuation">;</span>    SQL<span class="token operator">-</span><span class="token operator">></span>   <span class="token keyword">truncate</span> <span class="token keyword">table</span> t_user<span class="token punctuation">;</span>    <span class="token keyword">truncate</span>和<span class="token keyword">delete</span>的区别：   （<span class="token number">1</span>）<span class="token keyword">delete</span>可以有条件的删除，<span class="token keyword">truncate</span>直接将表的数据全部删除   （<span class="token number">2</span>）<span class="token keyword">delete</span>是DML语句，可以回退。<span class="token keyword">truncate</span>是DDL语句，立即生效，无法回退。    （<span class="token number">3</span>）如果是删除全表的数据，且数据量较大，<span class="token keyword">delete</span>语句效率比<span class="token keyword">truncate</span>语句低。 </code></pre><ol start="9"><li><h1 id="SQL-Plus-命令"><a href="#SQL-Plus-命令" class="headerlink" title="SQL Plus 命令"></a>SQL Plus 命令</h1><p><strong>1）设置行的长度</strong></p><pre><code>  一行显示200个字符再换行</code></pre></li></ol><pre class=" language-sql"><code class="language-sql">     SQL<span class="token operator">-</span><span class="token operator">></span>     <span class="token keyword">set</span> linesize <span class="token number">200</span><span class="token punctuation">;</span></code></pre><pre><code>**2）设置列的宽度**    **（1）列的属性是数字**             显示6个数字长度，格式定义为6个9             SQL-&gt;     column  id  format  999999;      **(2)  列的属性是字符串**            设置列的宽度为x个字符的长度，格式定义为：a数字            例如：将列password(字符型)显示最大宽度调整为8个字符</code></pre><pre class=" language-sql"><code class="language-sql">    SQL<span class="token operator">-</span><span class="token operator">></span>        <span class="token keyword">column</span>  password  format  <span class="token number">a8</span><span class="token punctuation">;</span></code></pre><pre><code>**3）设置分页显示**       set pagesize 100;   --每100行数据分页显示     set pagesize 0;     --设置为0表示不分页</code></pre><pre class=" language-sql"><code class="language-sql">emp表<span class="token keyword">create</span> <span class="token keyword">table</span> emp<span class="token punctuation">(</span>  empno number<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  ename varchar2<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  job varchar2<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  mgr number<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  hiredate <span class="token keyword">date</span><span class="token punctuation">,</span>  sal number<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  comm number<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  deptno number<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7369</span><span class="token punctuation">,</span><span class="token string">'SMITH'</span><span class="token punctuation">,</span><span class="token string">'CLERK'</span><span class="token punctuation">,</span><span class="token number">7902</span><span class="token punctuation">,</span>to_date<span class="token punctuation">(</span><span class="token string">'1980/12/17'</span><span class="token punctuation">,</span><span class="token string">'YYYY/MM/DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">800</span><span class="token punctuation">,</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7499</span><span class="token punctuation">,</span><span class="token string">'ALLEN'</span><span class="token punctuation">,</span><span class="token string">'SALESMAN'</span><span class="token punctuation">,</span><span class="token number">7698</span><span class="token punctuation">,</span>to_date<span class="token punctuation">(</span><span class="token string">'1981/2/20'</span><span class="token punctuation">,</span><span class="token string">'YYYY/MM/DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1600</span><span class="token punctuation">,</span><span class="token number">300</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7521</span><span class="token punctuation">,</span><span class="token string">'WARD'</span><span class="token punctuation">,</span><span class="token string">'SALESMAN'</span><span class="token punctuation">,</span><span class="token number">7698</span><span class="token punctuation">,</span>to_date<span class="token punctuation">(</span><span class="token string">'1981/2/22'</span><span class="token punctuation">,</span><span class="token string">'YYYY/MM/DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1250</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7566</span><span class="token punctuation">,</span><span class="token string">'JONES'</span><span class="token punctuation">,</span><span class="token string">'MANAGER'</span><span class="token punctuation">,</span><span class="token number">7839</span><span class="token punctuation">,</span>to_date<span class="token punctuation">(</span><span class="token string">'1981/4/2'</span><span class="token punctuation">,</span><span class="token string">'YYYY/MM/DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2975</span><span class="token punctuation">,</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7654</span><span class="token punctuation">,</span><span class="token string">'MARTIN'</span><span class="token punctuation">,</span><span class="token string">'SALESMAN'</span><span class="token punctuation">,</span><span class="token number">7698</span><span class="token punctuation">,</span>to_date<span class="token punctuation">(</span><span class="token string">'1981/9/28'</span><span class="token punctuation">,</span><span class="token string">'YYYY/MM/DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1250</span><span class="token punctuation">,</span><span class="token number">1400</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7698</span><span class="token punctuation">,</span><span class="token string">'BLAKE'</span><span class="token punctuation">,</span><span class="token string">'MANAGER'</span><span class="token punctuation">,</span><span class="token number">7839</span><span class="token punctuation">,</span>to_date<span class="token punctuation">(</span><span class="token string">'1981/5/1'</span><span class="token punctuation">,</span><span class="token string">'YYYY/MM/DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2850</span><span class="token punctuation">,</span><span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7782</span><span class="token punctuation">,</span><span class="token string">'CLARK'</span><span class="token punctuation">,</span><span class="token string">'MANAGER'</span><span class="token punctuation">,</span><span class="token number">7839</span><span class="token punctuation">,</span>to_date<span class="token punctuation">(</span><span class="token string">'1981/6/9'</span><span class="token punctuation">,</span><span class="token string">'YYYY/MM/DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2450</span><span class="token punctuation">,</span><span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7788</span><span class="token punctuation">,</span><span class="token string">'SCOTT'</span><span class="token punctuation">,</span><span class="token string">'ANALYST'</span><span class="token punctuation">,</span><span class="token number">7566</span><span class="token punctuation">,</span>to_date<span class="token punctuation">(</span><span class="token string">'1987/4/19'</span><span class="token punctuation">,</span><span class="token string">'YYYY/MM/DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7839</span><span class="token punctuation">,</span><span class="token string">'KING'</span><span class="token punctuation">,</span><span class="token string">'PRESIDENT'</span><span class="token punctuation">,</span><span class="token boolean">NULL</span><span class="token punctuation">,</span>to_date<span class="token punctuation">(</span><span class="token string">'1981/11/17'</span><span class="token punctuation">,</span><span class="token string">'YYYY/MM/DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">,</span><span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7844</span><span class="token punctuation">,</span><span class="token string">'TURNER'</span><span class="token punctuation">,</span><span class="token string">'SALESMAN'</span><span class="token punctuation">,</span><span class="token number">7698</span><span class="token punctuation">,</span>to_date<span class="token punctuation">(</span><span class="token string">'1981/9/8'</span><span class="token punctuation">,</span><span class="token string">'YYYY/MM/DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1500</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7876</span><span class="token punctuation">,</span><span class="token string">'ADAMS'</span><span class="token punctuation">,</span><span class="token string">'CLERK'</span><span class="token punctuation">,</span><span class="token number">7788</span><span class="token punctuation">,</span>to_date<span class="token punctuation">(</span><span class="token string">'1987/5/23'</span><span class="token punctuation">,</span><span class="token string">'YYYY/MM/DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1100</span><span class="token punctuation">,</span><span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7900</span><span class="token punctuation">,</span><span class="token string">'JAMES'</span><span class="token punctuation">,</span><span class="token string">'CLERK'</span><span class="token punctuation">,</span><span class="token number">7698</span><span class="token punctuation">,</span>to_date<span class="token punctuation">(</span><span class="token string">'1981/12/3'</span><span class="token punctuation">,</span><span class="token string">'YYYY/MM/DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">950</span><span class="token punctuation">,</span><span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7902</span><span class="token punctuation">,</span><span class="token string">'FORD'</span><span class="token punctuation">,</span><span class="token string">'ANALYST'</span><span class="token punctuation">,</span><span class="token number">7566</span><span class="token punctuation">,</span>to_date<span class="token punctuation">(</span><span class="token string">'1981/12/3'</span><span class="token punctuation">,</span><span class="token string">'YYYY/MM/DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7934</span><span class="token punctuation">,</span><span class="token string">'MILLER'</span><span class="token punctuation">,</span><span class="token string">'CLERK'</span><span class="token punctuation">,</span><span class="token number">7782</span><span class="token punctuation">,</span>to_date<span class="token punctuation">(</span><span class="token string">'1982/1/23'</span><span class="token punctuation">,</span><span class="token string">'YYYY/MM/DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1300</span><span class="token punctuation">,</span><span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dept表<span class="token keyword">create</span> <span class="token keyword">table</span> dept<span class="token punctuation">(</span>  deptno number<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  dname varchar2<span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  loc varchar2<span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> dept <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'ACCOUNTING'</span><span class="token punctuation">,</span><span class="token string">'NEWYORK'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> dept <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token string">'RESEARCH'</span><span class="token punctuation">,</span><span class="token string">'DALLAS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> dept <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token string">'SALES'</span><span class="token punctuation">,</span><span class="token string">'CHICAGO'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> dept <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token string">'OPERATIONS'</span><span class="token punctuation">,</span><span class="token string">'BOSTON'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="12-Oracle字符串操作"><a href="#12-Oracle字符串操作" class="headerlink" title="12 .Oracle字符串操作"></a>12 .Oracle字符串操作</h1><h6 id="1）字符串类型"><a href="#1）字符串类型" class="headerlink" title="1）字符串类型"></a>1）字符串类型</h6><p>​         <strong>（1）char(n)</strong><br>​      表示定常字符串(方便查询)<br>​      最长放入n个字符，放入的数据如果不够n个字符则补空格，无论如何都占n个<br>​      字符的长度<br>​                  char(5)   ‘abc  ‘<br>​         <strong>（2）varchar2</strong><br>​       表示字符串数据类型，用来在表中存放字符串信息，如姓名、职业、地址等；<br>​       char存储定长字符，即存不满补空格，varchar2存放变长字符，存多少占用多少；<br>​           例如：char(100) :存放10个字母，补齐90个空格，实际占用100，浪费空间,节省时间<br>​                     varchar2(100):存放10个字母，实际占用10，浪费时间，节省空间<br>​        char最大取值为2000字节，最多保存2000个英文字符，1000个汉字(GBK),varchar2最<br>​            大取值为4000个英文字符，2000个汉字(GBK);<br>​        char可以不指定长度，默认为1，varchar2必须指定长度；<br>​            name char; √== name char(1);        name varchar2; ×<br>​          (3)  long<br>​        （4）clob (Character Large Object)字符大对象<br>​          b-&gt;k-&gt;m-&gt;g   1g=1024m   1m=1024k  1k=1024b<br>​          long：是varchar2加长版，存储变长字符串，最多达2GB的字符串数据<br>​          clob：存储定长或变长字符串，最大达4GB的字符串数据<br>​          <em>建议：Oracle建议开发中使用cl</em>ob替代long类型，因为long类型有很多的限制，如**​                     <em>每个表中只能有1个long类型的列，不能建立索引，不能出现在查询条件中..**</em><br>​      </p><pre class=" language-sql"><code class="language-sql">  SQL<span class="token operator">-</span><span class="token operator">></span>          <span class="token keyword">create</span> <span class="token keyword">table</span> student<span class="token punctuation">(</span>              id number<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>              name long<span class="token punctuation">,</span>              address clob         <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">drop</span> <span class="token keyword">table</span> student<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">--删除表</span>         <span class="token keyword">create</span> <span class="token keyword">table</span> student<span class="token punctuation">(</span>              id number<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>              name long<span class="token punctuation">,</span>              address long         <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">--报错误</span>        <span class="token keyword">create</span> <span class="token keyword">table</span> student<span class="token punctuation">(</span>             id number<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             name clob<span class="token punctuation">,</span>             address clob        <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="2）字符串函数"><a href="#2）字符串函数" class="headerlink" title="2）字符串函数"></a><strong>2）字符串函数</strong></h6><p>​       <strong>（1）concat 和   ||      字符串连接函数</strong><br>​         语法： concat(char1,char2)<br>​                     该函数返回两个字符串连接后的结果，两个参数char1和char2是要连接的两个<br>​                     字符串。<br>​                     等价操作：连接操作符  ||<br>​                                  </p><pre class=" language-sql"><code class="language-sql">    concat<span class="token punctuation">(</span>char1<span class="token punctuation">,</span>char2<span class="token punctuation">)</span>  <span class="token operator">=</span><span class="token operator">=</span> char1 <span class="token operator">||</span> char2</code></pre><p>​                     如果char和char2任何一个为null，相当于连接了一个空格<br>​        </p><pre class=" language-sql"><code class="language-sql">  SQL<span class="token operator">-</span><span class="token operator">></span>          <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span>   查询的是emp表中所有列的数据           查询emp表中姓名和工资两列数据          <span class="token keyword">select</span> ename<span class="token punctuation">,</span>sal <span class="token keyword">from</span> emp<span class="token punctuation">;</span>              <span class="token keyword">select</span>  concat<span class="token punctuation">(</span>ename <span class="token punctuation">,</span> <span class="token string">':'</span><span class="token punctuation">)</span>  <span class="token keyword">from</span> emp<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">--> JAMES:</span>          <span class="token keyword">select</span>  concat<span class="token punctuation">(</span>concat<span class="token punctuation">(</span>ename<span class="token punctuation">,</span><span class="token string">':'</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> sal<span class="token punctuation">)</span>  <span class="token keyword">from</span> emp<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">--> JAMES:2500</span>          等价写法： <span class="token keyword">select</span> ename <span class="token operator">||</span>  <span class="token string">':'</span>  <span class="token operator">||</span> sal  <span class="token keyword">from</span> emp<span class="token punctuation">;</span>          把提成和工资连接          <span class="token keyword">select</span> comm <span class="token operator">||</span> sal <span class="token keyword">from</span> emp<span class="token punctuation">;</span>          <span class="token keyword">select</span> sal <span class="token operator">||</span> comm <span class="token operator">||</span> empno <span class="token keyword">from</span> emp<span class="token punctuation">;</span></code></pre><p>​          (说明：连接的null为空格，空格查询的时候不显示出来)<br>​        <strong>（2）length函数   –返回字符串的长度</strong><br>​                语法： length(char)   char表示的是字符串，函数返回字符串的长度<br>​                如果(char)字符串的数据类型是varchar2，返回字符串的实际长度；<br>​                如果(char)字符串的数据类型是char,返回长度还要包括后补的空格<br>​                      name varchar2(100)  – ‘ab’      length(name)–&gt;2<br>​                      name char(100)         –’ab….’    length(name)–&gt;100<br>​     </p><pre class=" language-sql"><code class="language-sql">      SQL<span class="token operator">-</span><span class="token operator">></span>             <span class="token keyword">select</span> ename <span class="token keyword">from</span> emp<span class="token punctuation">;</span>           <span class="token keyword">select</span> ename<span class="token punctuation">,</span> length<span class="token punctuation">(</span>ename<span class="token punctuation">)</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span>           <span class="token keyword">create</span> <span class="token keyword">table</span> mytest<span class="token punctuation">(</span>                name varchar2<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                address char<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>          <span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">insert</span> <span class="token keyword">into</span> mytest <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">'zs'</span><span class="token punctuation">,</span><span class="token string">'ab'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">select</span> length<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> length<span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token keyword">from</span> mytest<span class="token punctuation">;</span></code></pre><p>​    <strong>（3）upper   lower    initcap函数</strong><br>​           大小写转换的函数，用来转换字符的大小写<br>​           upper(char) 用于将字符转换为大写形式<br>​           lower(char) 用于将字符转换为小写形式<br>​           initcap(char)用于将字符串中每一个单词的首字母大小，其它字母小写<br>​                                (单词之间用空格和非字母字符分隔开的)<br>​           如果输入的参数是null值，仍然返回的是null值<br>​         </p><pre class=" language-sql"><code class="language-sql"> SQL<span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">insert</span> <span class="token keyword">into</span> emp<span class="token punctuation">(</span>empno<span class="token punctuation">,</span>ename<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span><span class="token string">'helloworld'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">select</span> ename<span class="token punctuation">,</span> upper<span class="token punctuation">(</span>ename<span class="token punctuation">)</span><span class="token punctuation">,</span> lower<span class="token punctuation">(</span>ename<span class="token punctuation">)</span><span class="token punctuation">,</span> initcap<span class="token punctuation">(</span>ename<span class="token punctuation">)</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span>          <span class="token keyword">insert</span> <span class="token keyword">into</span> emp<span class="token punctuation">(</span>empno<span class="token punctuation">,</span>ename<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1002</span><span class="token punctuation">,</span><span class="token string">'ho wo_d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>​     <strong>（4）trim   ltrim  rtrim 函数</strong><br>​            1）去掉空格<br>​             </p><pre class=" language-sql"><code class="language-sql">    trim<span class="token punctuation">(</span>char<span class="token punctuation">)</span>  去掉字符串两边空格                 ltrim<span class="token punctuation">(</span>char<span class="token punctuation">)</span> 去掉字符串左边空格                   rtrim<span class="token punctuation">(</span>char<span class="token punctuation">)</span> 去掉字符串右边空格           SQL<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">create</span> <span class="token keyword">table</span> t1<span class="token punctuation">(</span>id number<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> name char<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span><span class="token string">'abcd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1002</span><span class="token punctuation">,</span><span class="token string">' bb '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">select</span> name<span class="token punctuation">,</span> trim<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span>                 <span class="token keyword">select</span> name<span class="token operator">||</span>id <span class="token keyword">from</span> t1<span class="token punctuation">;</span>                 <span class="token keyword">select</span> name<span class="token operator">||</span>id<span class="token punctuation">,</span> rtrim<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token operator">||</span>id <span class="token keyword">from</span> t1<span class="token punctuation">;</span></code></pre><h6 id="2）截去字符串"><a href="#2）截去字符串" class="headerlink" title="2）截去字符串"></a>2）截去字符串</h6><p>​            </p><pre class=" language-sql"><code class="language-sql">      trim<span class="token punctuation">(</span><span class="token number">c2</span> <span class="token keyword">from</span> <span class="token number">c1</span><span class="token punctuation">)</span>  从<span class="token number">c1</span>的前后截去<span class="token number">c2</span>，<span class="token number">c1</span>和<span class="token number">c2</span>是字符串                  ltrim<span class="token punctuation">(</span><span class="token number">c1</span><span class="token punctuation">,</span><span class="token number">c2</span><span class="token punctuation">)</span>          从<span class="token number">c1</span>的左边截去<span class="token number">c2</span>                  rtrim<span class="token punctuation">(</span><span class="token number">c1</span><span class="token punctuation">,</span><span class="token number">c2</span><span class="token punctuation">)</span>         从<span class="token number">c1</span>的右边截去<span class="token number">c2</span>                 SQL<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1003</span><span class="token punctuation">,</span>trim<span class="token punctuation">(</span><span class="token string">'a'</span> <span class="token keyword">from</span> <span class="token string">'aba'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">--b</span>                        <span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1004</span><span class="token punctuation">,</span>ltrim<span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">--bc</span></code></pre><p>​       <strong>（5）lpad  rpad函</strong>数​                补位函数，语法：<br>​               </p><pre class=" language-sql"><code class="language-sql"> lpad<span class="token punctuation">(</span>char1<span class="token punctuation">,</span> n<span class="token punctuation">,</span> char2<span class="token punctuation">)</span>左补位函数，在字符串char1的左边用char2补足到n位                rpad<span class="token punctuation">(</span>char1<span class="token punctuation">,</span> n<span class="token punctuation">,</span> char2<span class="token punctuation">)</span>右补位函数，在字符串char1的右边用char2补足到n位                SQL<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">select</span> ename<span class="token punctuation">,</span> sal <span class="token keyword">from</span> emp<span class="token punctuation">;</span>                       <span class="token keyword">select</span> ename<span class="token punctuation">,</span> sal<span class="token punctuation">,</span> lpad<span class="token punctuation">(</span>sal<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'$'</span><span class="token punctuation">)</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span></code></pre><p>​         <strong>(6)substr函数   –截取函数</strong><br>​             语法： substr(char, m, n) 用于获取字符串的子串，函数返回char中从m位开始<br>​                         取n个字符<br>​                         字符串的首位计算从1开始<br>​                         如果m=0，则从首字符开始，如果m的取值为负数，则从尾部开始<br>​                         如果没有设置n，或者n的长度超过了char的长度,则取到字符串末尾为止<br>​            </p><pre class=" language-sql"><code class="language-sql"> SQL<span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span> substr<span class="token punctuation">(</span><span class="token string">'abcdefg'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">--cdef</span>                         <span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">102</span><span class="token punctuation">,</span> substr<span class="token punctuation">(</span><span class="token string">'abcdefg'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--abcd</span>                         <span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">103</span><span class="token punctuation">,</span> substr<span class="token punctuation">(</span><span class="token string">'abcdefg'</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">--f</span>                         <span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">104</span><span class="token punctuation">,</span> substr<span class="token punctuation">(</span><span class="token string">'abcdefg'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">--bcdefg</span></code></pre><p>​         <strong>（7）instr函数</strong><br>​               语法： instr(char1, char2, n, m) 返回字串char2在源字符串char1中的位置<br>​                          从n的位置开始搜索，没有指定n，默认从第1个字符开始搜索<br>​                          m用于指定子串的第m次出现次数，如果不指定默认取值为1<br>​             </p><pre class=" language-sql"><code class="language-sql">   SQL<span class="token operator">-</span><span class="token operator">></span>    从第<span class="token number">1</span>个字符开始搜索，第<span class="token number">1</span>次出现的位置                 <span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>instr<span class="token punctuation">(</span><span class="token string">'abcabcabc'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   id<span class="token operator">=</span><span class="token number">2</span>                             从第<span class="token number">3</span>个字符开始搜索，第<span class="token number">2</span>次出现<span class="token string">'b'</span>的位置                 <span class="token keyword">insert</span> <span class="token keyword">into</span> t1<span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span>instr<span class="token punctuation">(</span><span class="token string">'abcabcabc'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    id<span class="token operator">=</span><span class="token number">8</span></code></pre><ol start="13"><li><h1 id="Oracle数值操作"><a href="#Oracle数值操作" class="headerlink" title="Oracle数值操作"></a>Oracle数值操作</h1><h6 id="1）数值类型"><a href="#1）数值类型" class="headerlink" title="1）数值类型"></a>1）数值类型</h6><p> <strong>（1）number(p)  表示整数</strong></p><pre><code>      p表示数字的总位数，取值为1-38</code></pre><p> <strong>（2）number(p, s)   表示浮点数</strong></p><pre><code>      p表示可以存储的最大数字长度（不包括左右两边的0）   03.1400      s表示在小数点右边的最大数字长度（包括左侧的0）    3.00014     注意：指定了s但是没有指定p，则p默认值为38</code></pre></li></ol><pre><code> ```sql   SQL-&gt;   create table m1(id number(*,2) );                        desc m1; ``` ######    2）数值函数  **（1）round函数  四舍五入函数**           语法：  round(n, m)                 参数中的n可以是任意数字，指要被处理的数字                 m必须是整数                 m取正数则四舍五入到小数点后第m位                 m取0值则四舍五入到整数位                 m取负数，则四舍五入到小数点前m位                 m缺省，默认值为0 ```sql SQL-&gt;    create table mytest(id number(10,4));    insert into mytest values(45.678);    insert into mytest values(round(45.678, 2));            --45.68    insert into mytest values(round(45.678, 0));           --46    insert into mytest values(round(45.678, -1));          --50 ``` **（2）trunc函数    用于截取**          语法： trunc(n, m)  n和m的定义和round(n,m)相同，不同的是按照截取的方式                    处理n ```sql   SQL-&gt; insert into mytest values(trunc(45.678, 2));   --45.67                      insert into mytest values(trunc(45.678, 0));   --45                      insert into mytest values(trunc(45.678, -1));   --40 ```  **（3）mod函数   取余函数**        语法：mod(m, n)   返回m除以n后的余数，如果n为0则直接返回m        SQL-&gt;  emp表中工资按1000取余数 ```sql  select sal, mod(sal, 1000) from emp; ```  **（4）ceil和floor函数**         语法：ceil(n)  取大于或等于n的最小整数值                    floor(n)  取小于或等于n的最大整数值 ```sql     SQL-&gt; insert into mytest values(ceil(45.678));   --46                     insert into mytest values(floor(45.678));   --45 ``` **（2）trunc函数    用于截取**          语法： trunc(n, m)  n和m的定义和round(n,m)相同，不同的是按照截取的方式                    处理n ```sql    SQL-&gt; insert into mytest values(trunc(45.678, 2));   --45.67                      insert into mytest values(trunc(45.678, 0));   --45                      insert into mytest values(trunc(45.678, -1));   --40 ```  **（3）mod函数   取余函数**        语法：mod(m, n)   返回m除以n后的余数，如果n为0则直接返回m ```sql SQL-&gt;  emp表中工资按1000取余数        select sal, mod(sal, 1000) from emp; ```  **（4）ceil和floor函数**         语法：ceil(n)  取大于或等于n的最小整数值                    floor(n)  取小于或等于n的最大整数值         SQL-&gt; insert into mytest values(ceil(45.678));   --46                     insert into mytest values(floor(45.678));   --45</code></pre><h1 id="14-Oracle日期操作"><a href="#14-Oracle日期操作" class="headerlink" title="14 Oracle日期操作"></a>14 Oracle日期操作</h1><h6 id="1）日期类型"><a href="#1）日期类型" class="headerlink" title="1）日期类型"></a>1）日期类型</h6><p>​       <strong>（1）date</strong><br>​                 Oracle中最常用的日期类型，用来保存日期和时间<br>​        <strong>（2）timestamp</strong><br>​                 与date的区别是不仅可以保存日期和时间，还能保存小数秒，精确到ns（纳秒）</p><h6 id="2）日期关键字"><a href="#2）日期关键字" class="headerlink" title="2）日期关键字"></a>2）日期关键字</h6><p>​         <strong>（1）sysdate</strong><br>​                 是一个Oracle的内部函数，返回当前的系统时间，精确到秒<br>​                 默认显示格式  DD-MM-YY     16-10月-18<br>​         <strong>（2）systimestamp</strong><br>​                内部函数，返回当前系统时间，精确到毫秒</p><h6 id="3）日期转换函数"><a href="#3）日期转换函数" class="headerlink" title="3）日期转换函数"></a>3）日期转换函数</h6><p>​          <strong>（1）to_date函数：将字符串按照定制格式转换为日期类型</strong><br>​               </p><pre class=" language-sql"><code class="language-sql">  语法： to_date<span class="token punctuation">(</span>char<span class="token punctuation">,</span> fmt<span class="token punctuation">)</span>                            char表示要转换的字符串      fmt表示定制的格式                            常见的日期格式：                            YY          <span class="token number">2</span>位数字的年份                            YYYY      <span class="token number">4</span>位数字的年份                            MM        <span class="token number">2</span>位数字的月份      <span class="token number">10</span>                            MON      简拼的月份            <span class="token number">10</span>月                            MONTH  全拼的月份           <span class="token number">10</span>月                            DD          <span class="token number">2</span>位数字的天          <span class="token number">16</span>                            DY           周几的缩写                            DAY        周几的全拼                            HH24     <span class="token number">24</span>小时制的小时                            HH12     <span class="token number">12</span>小时制的小时                            MI           显示分钟                            SS            显示秒              SQL<span class="token operator">-</span><span class="token operator">></span>查询<span class="token string">'1983-01-01'</span>以后入职的员工               <span class="token keyword">select</span> ename<span class="token punctuation">,</span> hiredate <span class="token keyword">from</span> emp               <span class="token keyword">where</span> hiredate<span class="token operator">></span>to_date<span class="token punctuation">(</span><span class="token string">'1983-01-01'</span><span class="token punctuation">,</span><span class="token string">'YYYY-MM-DD'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-sql"><code class="language-sql">       （<span class="token number">2</span>）to_char函数：将日期类型的数据转换为字符串类型             语法：to_char<span class="token punctuation">(</span><span class="token keyword">date</span><span class="token punctuation">,</span>fmt<span class="token punctuation">)</span>  将日期类型的数据<span class="token keyword">date</span>按照fmt格式转换为字符串类型           SQL<span class="token operator">-</span><span class="token operator">></span>将emp表中的入职日期按照  <span class="token string">"xxxx年xx月xx日 xx时xx分xx秒"</span> 格式输出            <span class="token keyword">select</span> ename<span class="token punctuation">,</span> hiredate <span class="token keyword">from</span> emp<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//说明：''表示字符串，在''中再次使用字符串用""</span>            <span class="token keyword">select</span> ename<span class="token punctuation">,</span> to_char<span class="token punctuation">(</span>hiredate<span class="token punctuation">,</span><span class="token string">'YYYY "年" MM "月" DD "日" HH24 MI  SS'</span><span class="token punctuation">)</span>             <span class="token keyword">from</span> emp<span class="token punctuation">;</span> <span class="token number">4</span>）日期常用的函数       （<span class="token number">1</span>）last_day函数               语法：last_day<span class="token punctuation">(</span><span class="token keyword">date</span><span class="token punctuation">)</span>：返回日期<span class="token keyword">date</span>所在月的最后一天               SQL<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">select</span> sysdate<span class="token punctuation">,</span> last_day<span class="token punctuation">(</span>sysdate<span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>         （<span class="token number">2</span>）add_months函数               语法：add_months<span class="token punctuation">(</span><span class="token keyword">date</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>：返回日期<span class="token keyword">date</span>加上i个月的日期值                参数i可以任意数字，大部分时候取正值整数                如果i是小数，将会被截取整数后再参与运算                如果i是负数，将获得的是减去i个月后的日期值               SQL<span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">select</span> sysdate<span class="token punctuation">,</span> add_months<span class="token punctuation">(</span>sysdate<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>                                     <span class="token keyword">select</span> sysdate<span class="token punctuation">,</span> add_months<span class="token punctuation">(</span>sysdate<span class="token punctuation">,</span><span class="token number">1.7</span><span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>                           <span class="token keyword">select</span> sysdate<span class="token punctuation">,</span>add_months<span class="token punctuation">(</span>sysdate<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>          （<span class="token number">3</span>）months_between               语法：months_between<span class="token punctuation">(</span>date1<span class="token punctuation">,</span>date2<span class="token punctuation">)</span>：计算date1和date2两个日期值                          之间间隔了多少个月               实际运算是date1<span class="token operator">-</span>date2，如果date2时间比date1晚<span class="token punctuation">,</span>会得到负值               除非两个日期间隔的是整数月，否则会得到带小数位的结果               SQL<span class="token operator">-</span><span class="token operator">></span><span class="token keyword">select</span> months_between<span class="token punctuation">(</span><span class="token string">'16-10月-18'</span><span class="token punctuation">,</span><span class="token string">'16-12月-18'</span><span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>              <span class="token number">1</span>月  <span class="token number">2</span>月  <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token number">9</span>月 <span class="token number">10</span>月 <span class="token number">11</span>月 <span class="token number">12</span>月               计算<span class="token number">2009</span>年<span class="token number">9</span>月<span class="token number">1</span>日到<span class="token number">2009</span>年<span class="token number">10</span>月<span class="token number">10</span>日之间间隔了多少个月               <span class="token keyword">select</span> months_between<span class="token punctuation">(</span><span class="token string">'10-10月-09'</span><span class="token punctuation">,</span><span class="token string">'01-9月-09'</span><span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>             （<span class="token number">4</span>）next_day函数                   语法：next_day<span class="token punctuation">(</span><span class="token keyword">date</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span> 返回<span class="token keyword">date</span>日期数据的下一个周几，周几                              是由参数num来决定的                              num的取值可以直接用数字<span class="token number">1</span><span class="token operator">-</span><span class="token number">7</span>表示周日<span class="token operator">-</span>周六                  SQL<span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">select</span> sysdate<span class="token punctuation">,</span> next_day<span class="token punctuation">(</span>sysdate<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>               （<span class="token number">5</span>）least  greatest函数                     比较函数                     语法：least<span class="token punctuation">(</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">--求最小值</span>                                greatest<span class="token punctuation">(</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">--求最大值</span>                     可以有多个参数，返回结果是参数列表中最大或最小的值                     多个参数的数据类型必须一致，如果不一致会报错误                      SQL<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">select</span> least<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>                                   <span class="token keyword">select</span> greatest<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>                （<span class="token number">6</span>）extract函数                      语法：extract<span class="token punctuation">(</span><span class="token keyword">date</span> <span class="token keyword">from</span> <span class="token keyword">datetime</span><span class="token punctuation">)</span> 从参数<span class="token keyword">datetime</span>中提取参数<span class="token keyword">date</span>                                 指定的数据，比如提取年、月、日等                     SQL<span class="token operator">-</span><span class="token operator">></span>从系统时间systimestamp中提取年月日时分秒                     <span class="token keyword">select</span> extract<span class="token punctuation">(</span>year <span class="token keyword">from</span> systimestamp<span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>                     <span class="token keyword">select</span> extract<span class="token punctuation">(</span>month <span class="token keyword">from</span> systimestamp<span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>                     <span class="token keyword">select</span> extract<span class="token punctuation">(</span>day <span class="token keyword">from</span> systimestamp<span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>                     <span class="token keyword">select</span> extract<span class="token punctuation">(</span>minute <span class="token keyword">from</span> systimestamp<span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>                     <span class="token keyword">select</span> extract<span class="token punctuation">(</span>second <span class="token keyword">from</span> systimestamp<span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>                     <span class="token keyword">select</span> extract<span class="token punctuation">(</span>hour <span class="token keyword">from</span> systimestamp<span class="token punctuation">)</span><span class="token keyword">from</span> dual<span class="token punctuation">;</span>  <span class="token punctuation">(</span>hour<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span></code></pre><h1 id="15-Oracle中的虚表"><a href="#15-Oracle中的虚表" class="headerlink" title="15 Oracle中的虚表"></a>15 Oracle中的虚表</h1><p>​     dual表，是Oracle中已经设置好的虚表，表中只有一行数据X<br>​     </p><pre class=" language-sql"><code class="language-sql">    <span class="token number">1</span><span class="token punctuation">.</span>oracle中的dual表示一个单行单列的虚拟表。    <span class="token number">2</span><span class="token punctuation">.</span>Dual表是oracle与数据字典一起自动创建的一个表，        这个表只有<span class="token number">1</span>列：<span class="token keyword">DUMMY</span>，数据类型为VERCHAR2<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>，        dual表中只有一个数据<span class="token string">'X'</span>，Oracle有内部逻辑保证dual表中永远只有一条数据。    <span class="token number">3</span><span class="token punctuation">.</span>Dual表主要用来选择系统变量或求一个表达式的值    没有表名就没有办法查询，而时间日期并不存放在任何表中，    于是这个dual虚拟表的概念就被引入<span class="token punctuation">,</span>Dual是Oracle中的一个实际存在的表，    任何用户均可读取，常用在没有目标表的<span class="token keyword">SELECT</span>语句块中 SQL<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">select</span> <span class="token number">1</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>              <span class="token keyword">select</span> upper<span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span>              <span class="token keyword">select</span> sysdate <span class="token keyword">from</span> emp<span class="token punctuation">;</span>   报错              <span class="token keyword">select</span> sysdate <span class="token keyword">from</span> dual<span class="token punctuation">;</span>              <span class="token keyword">select</span> systimestamp <span class="token keyword">from</span> dual<span class="token punctuation">;</span></code></pre><h1 id="16-空值操作"><a href="#16-空值操作" class="headerlink" title="16 空值操作"></a>16 空值操作</h1><h6 id="1）空值null的含义"><a href="#1）空值null的含义" class="headerlink" title="1）空值null的含义"></a>1）空值null的含义</h6><p>​           有时表中的某些字段值，数据未知或暂时不存在，取值为null<br>​           任何数据类型均可取值null</p><h6 id="2）空值null的操作"><a href="#2）空值null的操作" class="headerlink" title="2）空值null的操作"></a>2）空值null的操作</h6><p>​         <strong>（1）插入null值</strong><br>​         </p><pre class=" language-sql"><code class="language-sql">   SQL<span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">create</span> <span class="token keyword">table</span> stu<span class="token punctuation">(</span>                              id number<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                              name char<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                              gender char<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                        <span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token keyword">insert</span> <span class="token keyword">into</span> stu<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>gender<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span><span class="token string">'zs'</span><span class="token punctuation">,</span><span class="token string">'m'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">--显式插入null值</span>                       <span class="token keyword">insert</span> <span class="token keyword">into</span> stu<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>gender<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1002</span><span class="token punctuation">,</span><span class="token string">'ls'</span><span class="token punctuation">,</span><span class="token boolean">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">--隐式插入null值</span>                       <span class="token keyword">insert</span> <span class="token keyword">into</span> stu<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1003</span><span class="token punctuation">,</span><span class="token string">'ww'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​          <strong>(2)更新/修改null值</strong><br>​              update stu set gender=null;<br>​              注意这种更新只有在此列没有非空约束的情况才可以操作<br>​              如果某列有非空(not null)约束，则无法更新为null值，上述代码会报错的<br>​           <strong>(3)null查询条件</strong><br>​             </p><pre class=" language-sql"><code class="language-sql"> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> stu <span class="token keyword">where</span> gender <span class="token operator">is</span> <span class="token boolean">null</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//注意是is，而不是=号</span>              <span class="token keyword">update</span> stu <span class="token keyword">set</span> gender<span class="token operator">=</span><span class="token string">'m'</span> <span class="token keyword">where</span> gender <span class="token operator">is</span> <span class="token boolean">null</span><span class="token punctuation">;</span></code></pre><p>​            总结：给字段设置(更新)为null值用=号，查询条件中判断是否为null值<br>​                       用is<br>​            <strong>(4)非空约束</strong><br>​              非空(not null)约束用于确保字段值不为空<br>​              默认情况，任何列都允许有空值，但在实际的业务逻辑可能会要求某些列<br>​              不能取空值；<br>​              当某个字段设置了非空约束条件，这个字段中必须存在有效值，即执行插入<br>​              操作的时候，必须提供这个列的数据，当执行更新操作时，不能给这个列<br>​              设置为null。<br>​            </p><pre class=" language-sql"><code class="language-sql">  SQL<span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">create</span> <span class="token keyword">table</span> stu1<span class="token punctuation">(</span>                               id number<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>                               name char<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>                               gender char<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span>                          <span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token keyword">insert</span> <span class="token keyword">into</span> stu1<span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="3）空值null函数"><a href="#3）空值null函数" class="headerlink" title="3）空值null函数"></a>3）空值null函数</h6><p>​        <strong>(1) nvl函数</strong><br>​           语法：nvl(p1,p2)   将null转变为非null值<br>​            如果p1为null，则取值p2，p2是实际值,如果p1不为null，则还是用p1的值<br>​            p1和p2可以是任意数据类型，但是两个参数的数据类型必须是一致的<br>​            SQL-&gt;计算员工的月收入（底薪+绩效=月收入）<br>​           </p><pre class=" language-sql"><code class="language-sql"> <span class="token keyword">select</span> ename<span class="token punctuation">,</span>sal<span class="token punctuation">,</span>comm<span class="token punctuation">,</span>sal<span class="token operator">+</span>comm <span class="token keyword">from</span> emp<span class="token punctuation">;</span>            <span class="token keyword">select</span> ename<span class="token punctuation">,</span>sal<span class="token punctuation">,</span>comm<span class="token punctuation">,</span>sal<span class="token operator">+</span>nvl<span class="token punctuation">(</span>comm<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span></code></pre><p>​       <strong>（2）nvl2函数</strong><br>​           语法：nvl2(p1,p2,p3) 和nvl函数功能类似，都能将null转变为实际值<br>​            nvl2函数用来判断p1是否为null，如果不是null，返回p2的值，如果<br>​            是空，返回p3的值<br>​          </p><pre class=" language-sql"><code class="language-sql">  SQL<span class="token operator">-</span><span class="token operator">></span>计算员工的月收入            <span class="token keyword">select</span> ename<span class="token punctuation">,</span>sal<span class="token punctuation">,</span>comm<span class="token punctuation">,</span>nvl2<span class="token punctuation">(</span>comm<span class="token punctuation">,</span>sal<span class="token operator">+</span>comm<span class="token punctuation">,</span>sal<span class="token punctuation">)</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span></code></pre><ol start="17"><li><h1 id="SQL基础查询"><a href="#SQL基础查询" class="headerlink" title="SQL基础查询"></a>SQL基础查询</h1><h6 id="1）基本查询语句"><a href="#1）基本查询语句" class="headerlink" title="1）基本查询语句"></a>1）基本查询语句</h6><p>​    <strong>（1）from子句</strong><br>​       </p></li></ol><pre><code>```sql 指定要从哪个表中查询   from emp;           select * from 表名;```**（2）使用别名**       在SQL语句中可以通过使用列的别名改变标题的显示样式，或者表示计算结果的含义       语法：是列的别名跟在列名后，中间可以加或不加一个&quot;as&quot;关键字       别名默认显示为全大写，如果希望别名中区分大小写字符，或者别名中包含空格等       其它字符，必须用双引号引起来```sql  SQL-&gt; select empno,ename,sal*12 from emp;        select empno as id, ename  &quot;Name&quot; , sal*12 as &quot;Annual Salary&quot; from emp;```**（3）where子句**         where子句的功能限制查询结果         如果where子句中是和数字比较，*数字可以使用“单引号”引起来，也可以不用*         如果where子句中是和字符及日期类型的数据比较，则必须用“单引号”引起来```sql  SQL-&gt;             select ename from emp where deptno=20;                    select ename from emp where deptno=&#39;20&#39;;                    select ename from emp where job=CLERK;   --错误                       select ename from emp where job=&#39;CLERK&#39;;```**（4）select子句**         select用于指定要查询的列         如果要查询所有的列，可以在select后面使用*号         如果只查询特定的列，可以直接在select后面指定列名，列名之间用逗号隔开###### 2）查询条件  **（1）使用  &gt;    &lt;     &gt;=     &lt;=     !=     &lt;&gt;   =**    SQL-&gt;  查询职员中薪水低于2000元的职员信息                 select ename,sal from emp where sal&lt;2000;                 查询职员表中不属于部门10的员工信息(  !=  等价于 &lt;&gt; )                 select ename,sal,deptno from emp where deptno!=10;                 查询职员表中在1981年1月1日以后入职的职员信息                  select ename,hiredate from emp                  where hiredate&gt;&#39;1-1月-81&#39;;​              select ename,hiredate from emp​              where hiredate&gt;to_date(&#39;1981-1-1&#39;,&#39;YYYY-MM-DD&#39;); **(2) 使用and  or关键字**​      在SQL操作中，如果希望返回的结果必须满足多个条件，应该使用and操作符连接条件​      在SQL操作中，如果希望返回的结果满足多个条件之一即可，应该使用or```sql  SQL-&gt;查询薪水大于1000并且职位是&#39;CLERK&#39;的职员信息   select *from emp where sal&gt;1000 and lower(job) = &#39;clerk&#39;;              查询薪水大于1000或者职位是&#39;CLERK&#39;的职员信息        select ename,sal,job from emp where sal&gt;1000 or job = &#39;CLERK&#39;;``` **(3)使用like条件-- 模糊查询**      当用户在执行查询时，不能完全确定某些信息的查询条件，或者只知道信息的一部分，      可以借助于like来实现      like需要借助于两个通配符：      %：表示0到多个字符      _：表示单个字符      这两个通配符配合使用，构造灵活的匹配条件     SQL-&gt; select ename, job from emp where ename like &#39;_A%&#39;;**（4）使用  in  和  not in **     语法：in(list)   用来取出符合列表范围中的数据                list表示列表值，当列或表达式匹配于列表中的任何一个值时，条件为                true，该条记录会被显示出来                in也可以理解为范围比较操作符，只不过这个范围是一个指定的列表值。                          2000-6000   in(2000,3000,4000,5000,6000)                not in(list)   取出不符合此列表中的数据记录```sql SQL-&gt; 查询职位是MANAGER或者CLERK的员工select ename, job from emp               where job=&#39;MANAGER&#39; or job=&#39;CLERK&#39;;               //等价写法               select ename,job from emp               where job in(&#39;MANAGER&#39;,&#39;CLERK&#39;);               //查询不是部门10或20的员工              select ename,job,deptno from emp where deptno not in(10,20);``` **(3)使用like条件-- 模糊查询**      当用户在执行查询时，不能完全确定某些信息的查询条件，或者只知道信息的一部分，      可以借助于like来实现      like需要借助于两个通配符：      %：表示0到多个字符      _：表示单个字符      这两个通配符配合使用，构造灵活的匹配条件     SQL-&gt; select ename, job from emp where ename like &#39;_A%&#39;;（4）使用  in  和  not in      语法：in(list)   用来取出符合列表范围中的数据                list表示列表值，当列或表达式匹配于列表中的任何一个值时，条件为                true，该条记录会被显示出来                in也可以理解为范围比较操作符，只不过这个范围是一个指定的列表值。                          2000-6000   in(2000,3000,4000,5000,6000)                not in(list)   取出不符合此列表中的数据记录```sqlSQL-&gt; 查询职位是MANAGER或者CLERK的员工               select ename, job from emp               where job=&#39;MANAGER&#39; or job=&#39;CLERK&#39;;               //等价写法               select ename,job from emp               where job in(&#39;MANAGER&#39;,&#39;CLERK&#39;);               //查询不是部门10或20的员工              select ename,job,deptno from emp where deptno not in(10,20);``` **（5）between...and...**        语法：between...and...操作符用来查询某个值范围条件的数据        最常见的是使用在数字类型的数据范围上，但对字符类型和日期类型数据也同样使用```sqlSQL-&gt;  查询薪水在1500-3000之间的职员信息        select ename,sal from emp where sal&gt;=1500 and sal&lt;=3000;        select ename,sal from emp where sal between 1500 and 3000;```  **（6）  is null  和  is not null**       空值null是一个特殊的值，比较的时候不能用&quot;=&quot;号，必须使用is null，否则不能得到       正确的结果。```sqlSQL-&gt; 查询哪些员工的奖金数据为null                  select ename,sal,comm from emp where comm is null;```   **（7）使用any 和 all条件**         语法：  any(list)     all(list)         any和all不能单独使用，需要配合比较操作符(&gt; &lt; &gt;= &lt;=)一起使用         &gt;any(list) ：大于list中最小的值         &lt;any(list) ：小于list中最大的值         &gt;all(list)   ：大于list中最大的值         &lt;all(list)   ：小于list中最小的值```sql  SQL-&gt; select empno,ename,job,sal,deptno from emp                      where sal&gt;any(3500,4000,4500);```​     **（8）使用distinct**​          数据表中有可能存储相同数据的行，当执行查询操作时，默认情况会显示所有行，​          不管查询结果是否有重复数据​          当重复数据没有实际意思，经常会需要去掉重复值，需要用distinct来实现​        ```sql SQL-&gt;查询员工的部门编号                   select deptno from emp;                   查询员工的部门编号，去掉重复值                   select distinct deptno from emp;                   查询每个部门的职位                   select deptno,job from emp;                   查询每个部门的职位，去掉重复值                   select distinct deptno,job from emp;```​       **（9）查询条件中使用表达式和函数**​               当查询需要对选出的字段进行进一步计算，可以在数字列上使用算术表达式​               （+、-、*、/、mod）​               表达式符合四则运算的默认优先级，如果要改变优先级可以使用括号​               算术运算主要是针对数字类型的数据，对日期类型的数据可以做加减操作，表示​               在一个日期值上加或减一个天数​              ```sql SQL-&gt;          在查询条件中使用函数(将ename列的值先转换为小写,然后再和&#39;smith&#39;比较)              select ename from emp where lower(ename)=&#39;smith&#39;;              //先将&#39;smith&#39;转换成大写，再和ename列的值比较              select ename from emp where ename=upper(&#39;smith&#39;);             //查询条件中使用表达式             select ename,sal,sal*12 from emp where sal*12&gt;10000;```######    3）排序​      **（1）使用order by子句**​               对数据按照一定规则进行排序操作​              语法：  select column1,column2...​                           from  表​                           [where 条件]​                           [order by column]​               注意：order by子句必须出现在select语句的最后一个位置​              ```sql SQL-&gt;  查询emp表中员工姓名，部门号，并按照部门号排序                select ename, deptno from emp;                select ename, deptno from emp  order by deptno;```​        **（2）asc 和 desc**​                asc用来指定升序排序（默认），desc用来指定降序排序​                null值视为最大，升序排在最后，降序排在最前​              SQL-&gt;查询emp表中的数据，部门号为10，并按照mgr进行排序​                  select empno,ename,mgr,deptno from emp​                  where deptno=10​                  order by mgr;​              select empno,ename,mgr,deptno from emp​              where deptno=10​              order by mgr desc;​     **（3）多个列排序**​           当以多列作为排序标准，首先按照第一列进行排序，如果第一列数据相同，再​       以第二列进行排序，以此类推​           多列排序时，不管正序还是倒序，每个列都要单独设置排序方式​     ```sql   SQL-&gt;对员工表的职员排序，先按照部门编码进行正序排列，再按照薪水降序排列            select ename,deptno,sal            from emp            order by deptno asc, sal desc;```###### 4）聚合函数​    **（1）什么是聚合函数**​            聚合函数也称为分组函数、多行函数、集合函数，参与运算只返回一个结果​            当查询时需要做一些数据统计，比如：查询职员表中各部门职员的平均薪水，​            各部门的人数，这些需要统计的数据并不能在职员表中直观的列出，而是要​            根据现有的数据计算得到结果，这种功能可以使用聚合函数来实现。   **（2）聚合函数     MAX  MIN**​            用来取得列或表达式的最大值、最小值​            用来统计任何数据类型，包括数字、字符串和日期​           SQL-&gt; 查询员工表的最高薪水和最低薪水  参数是数字​                       select sal from emp order by sal;​                       select max(sal), min(sal) from emp;​                       查询最早和最晚的入职时间，参数是日期​                      select min(hiredate), max(hiredate) from emp;​    **(3) 聚合函数  AVG   SUM**​          用来统计列的平均值、和值​          只能操作数字类型​          忽略null值​       ```sql   SQL-&gt; 查询员工表中员工的平均薪水和薪水总和              select avg(sal), sum(sal) from emp;```   **(4) 聚合函数   count**         用来计算表中数据的条数         忽略null值```sqlSQL-&gt; 查询员工表中一共有多少条员工数据                     select count(*) from emp;                     查询员工表中有多少人是有提成的(忽略没有提成的员工数据)                     select count(comm) from emp;```   **（5）聚合函数对空值的处理**```sql select count(comm),sum(comm),avg(comm)from emp;       select count(comm),sum(comm),avg(nvl(comm,0))form emp;```</code></pre><h1 id="18-Oracle中的关联查询"><a href="#18-Oracle中的关联查询" class="headerlink" title="18  Oracle中的关联查询"></a>18  Oracle中的关联查询</h1><h6 id="1）关联查询的概念"><a href="#1）关联查询的概念" class="headerlink" title="1）关联查询的概念"></a>1）关联查询的概念</h6><p>​          实际应用中所需要的数据，经常会需要查询两个或两个以上的表<br>​          这种查询两个或两个以上数据表的查询叫做连接查询<br>​          连接查询通常建立在有相互关系的表之间<br>​         </p><pre class=" language-sql"><code class="language-sql"> dept    emp            <span class="token keyword">insert</span> <span class="token keyword">into</span> emp <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span><span class="token string">'ZS'</span><span class="token punctuation">,</span><span class="token string">'MANAGER'</span><span class="token punctuation">,</span><span class="token number">7839</span><span class="token punctuation">,</span>          to_date<span class="token punctuation">(</span><span class="token string">'1983-6-11'</span><span class="token punctuation">,</span><span class="token string">'YYYY-MM-DD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">commit</span><span class="token punctuation">;</span></code></pre><h6 id="2）关联查询的方式"><a href="#2）关联查询的方式" class="headerlink" title="2）关联查询的方式"></a>2）关联查询的方式</h6><p>​         <strong>（1）等值连接</strong><br>​                  是连接查询中最常见的一种，通常是在有关联关系的表间建立，并将连接条件<br>​                  设定为有关系的列，使用等号“=”连接相关的表<br>​                   emp–&gt;deptno<br>​                                    =                等值连接<br>​                   dept–&gt;deptno<br>​                   语法：  select  t1.列, t1.列, … t2.列,t2.列<br>​                                from    table1 t1, table2 t2<br>​                                where  t1.某列=t2.某列<br>​              </p><pre class=" language-sql"><code class="language-sql">   SQL<span class="token operator">-</span><span class="token operator">></span>查询职员的姓名、职位以及所在的部门的名字和所在城市                 <span class="token keyword">select</span> <span class="token number">e</span><span class="token punctuation">.</span>ename<span class="token punctuation">,</span> <span class="token number">e</span><span class="token punctuation">.</span>job<span class="token punctuation">,</span> <span class="token number">d</span><span class="token punctuation">.</span>dname<span class="token punctuation">,</span> <span class="token number">d</span><span class="token punctuation">.</span>loc                 <span class="token keyword">from</span>   emp <span class="token number">e</span><span class="token punctuation">,</span> dept <span class="token number">d</span>                 <span class="token keyword">where</span>  <span class="token number">e</span><span class="token punctuation">.</span>deptno<span class="token operator">=</span><span class="token number">d</span><span class="token punctuation">.</span>deptno<span class="token punctuation">;</span></code></pre><p>​          <strong>(2)内连接（内连接的结果是和等值连接一样的）</strong><br>​               内连接返回所有满足连接条件的记录，等值连接也是。<br>​               语法： select t1.列, t1.列, … t2.列…<br>​                           from   table1 t1 join table2 t2<br>​                           on  t1.某列=t2.某列<br>​              </p><pre class=" language-sql"><code class="language-sql"> SQL<span class="token operator">-</span><span class="token operator">></span>查询职员的姓名、职位以及所在的部门的名字和所在城市                         <span class="token keyword">select</span> <span class="token number">e</span><span class="token punctuation">.</span>ename<span class="token punctuation">,</span> <span class="token number">e</span><span class="token punctuation">.</span>job<span class="token punctuation">,</span> <span class="token number">d</span><span class="token punctuation">.</span>dname<span class="token punctuation">,</span> <span class="token number">d</span><span class="token punctuation">.</span>loc                         <span class="token keyword">from</span> emp <span class="token number">e</span> <span class="token keyword">join</span> dept <span class="token number">d</span>                         <span class="token keyword">on</span>  <span class="token number">e</span><span class="token punctuation">.</span>deptno<span class="token operator">=</span><span class="token number">d</span><span class="token punctuation">.</span>deptno<span class="token punctuation">;</span></code></pre><p>​          <strong>(3)外连接</strong><br>​               内连接返回满足条件的记录，外连接是不仅返回满足条件的记录，还将返回不满足<br>​               条件的记录，以驱动表为参照。<br>​              a 左外连接<br>​                 语法：  select  t1.列,…t2.列…<br>​                              from table1 t1 left outer join table t2<br>​                              on t1.某列=t2.某列<br>​                         驱动表： table1 t1<br>​            </p><pre class=" language-sql"><code class="language-sql">  SQL<span class="token operator">-</span><span class="token operator">></span>查询职员的姓名、职位以及所在的部门的名字和所在城市                         <span class="token keyword">select</span> <span class="token number">e</span><span class="token punctuation">.</span>ename<span class="token punctuation">,</span> <span class="token number">e</span><span class="token punctuation">.</span>job<span class="token punctuation">,</span> <span class="token number">d</span><span class="token punctuation">.</span>dname<span class="token punctuation">,</span> <span class="token number">d</span><span class="token punctuation">.</span>loc                         <span class="token keyword">from</span>  emp <span class="token number">e</span> <span class="token keyword">left</span> <span class="token keyword">outer</span> <span class="token keyword">join</span> dept <span class="token number">d</span>                         <span class="token keyword">on</span> <span class="token number">e</span><span class="token punctuation">.</span>deptno<span class="token operator">=</span><span class="token number">d</span><span class="token punctuation">.</span>deptno<span class="token punctuation">;</span></code></pre><h6 id="b-右外连接"><a href="#b-右外连接" class="headerlink" title="b 右外连接"></a>b 右外连接</h6><p>​                     语法：select t1.列，…t2.列<br>​                                from  table1 t1 right outer join table2 t2<br>​                                on  t1.某列=t2.某列<br>​                      驱动表： table2 t2<br>​               </p><pre class=" language-sql"><code class="language-sql"> SQL<span class="token operator">-</span><span class="token operator">></span>查询职员的姓名、职位以及所在的部门的名字和所在城市                          <span class="token keyword">select</span> <span class="token number">e</span><span class="token punctuation">.</span>ename<span class="token punctuation">,</span> <span class="token number">e</span><span class="token punctuation">.</span>job<span class="token punctuation">,</span> <span class="token number">d</span><span class="token punctuation">.</span>dname<span class="token punctuation">,</span> <span class="token number">d</span><span class="token punctuation">.</span>loc                          <span class="token keyword">from</span> emp <span class="token number">e</span> <span class="token keyword">right</span> <span class="token keyword">outer</span> <span class="token keyword">join</span> dept <span class="token number">d</span>                          <span class="token keyword">on</span> <span class="token number">e</span><span class="token punctuation">.</span>deptno<span class="token operator">=</span><span class="token number">d</span><span class="token punctuation">.</span>deptno<span class="token punctuation">;</span></code></pre><h6 id="c-全外连接"><a href="#c-全外连接" class="headerlink" title="c 全外连接"></a>c 全外连接</h6><p>​                   全外连接是指，除了返回满足条件的记录，还会返回不满足连接条件的所有<br>​                   其它行记录<br>​                   是左外连接和右外连接结果的总和<br>​                   语法：  select t1.列,…t2.列<br>​                                from  table1 t1 full outer join table2 t2<br>​                                on t1.某列=t2.某列<br>​                </p><pre class=" language-sql"><code class="language-sql"> SQL<span class="token operator">-</span><span class="token operator">></span>查询职员的姓名、职位以及所在的部门的名字和所在城市                         <span class="token keyword">select</span> <span class="token number">e</span><span class="token punctuation">.</span>ename<span class="token punctuation">,</span> <span class="token number">e</span><span class="token punctuation">.</span>job<span class="token punctuation">,</span> <span class="token number">d</span><span class="token punctuation">.</span>dname<span class="token punctuation">,</span> <span class="token number">d</span><span class="token punctuation">.</span>loc                         <span class="token keyword">from</span> emp <span class="token number">e</span> <span class="token keyword">full</span> <span class="token keyword">outer</span> <span class="token keyword">join</span> dept <span class="token number">d</span>                         <span class="token keyword">on</span> <span class="token number">e</span><span class="token punctuation">.</span>deptno<span class="token operator">=</span><span class="token number">d</span><span class="token punctuation">.</span>deptno<span class="token punctuation">;</span></code></pre><p>​          <strong>(4)自连接</strong><br>​               自连接是一种特殊的连接查询，数据的来源是同一个表，即关联关系来自于<br>​               同一个表中的多个列。<br>​               emp  empno<br>​                         mgr<br>​               自连接是通过将表用别名虚拟成两个表的方式来实现的查询<br>​                emp w    –&gt; 员工表–&gt;在员工表中可以看到我的部门经理的工号<br>​                emp m    –&gt; 管理表–&gt;在管理表中可以看到的是我的职员的工号<br>​               </p><pre class=" language-sql"><code class="language-sql">SQL<span class="token operator">-</span><span class="token operator">></span>查询出每个职员的经理名字，以及他们的职位编号               <span class="token keyword">select</span>  w<span class="token punctuation">.</span>empno<span class="token punctuation">,</span> w<span class="token punctuation">.</span>ename<span class="token punctuation">,</span> m<span class="token punctuation">.</span>empno<span class="token punctuation">,</span> m<span class="token punctuation">.</span>ename               <span class="token keyword">from</span>  emp w <span class="token keyword">join</span> emp m               <span class="token keyword">on</span>  w<span class="token punctuation">.</span>mgr<span class="token operator">=</span>m<span class="token punctuation">.</span>empno<span class="token punctuation">;</span></code></pre><h1 id="19-Oracle中的约束"><a href="#19-Oracle中的约束" class="headerlink" title="19 Oracle中的约束"></a>19 Oracle中的约束</h1><h6 id="1）约束的作用"><a href="#1）约束的作用" class="headerlink" title="1）约束的作用"></a>1）约束的作用</h6><p>​       约束的全称是约束条件，也称为完整性约束条件<br>​       约束是在数据表上强制执行的一些数据校验规则，当执行DML操作时，数据是必须符合<br>​       这些规则的，如果不符合则无法执行。<br>​       约束条件可以保证表中数据的完整性，保证数据间的商业逻辑</p><h3 id="2）约束的种类"><a href="#2）约束的种类" class="headerlink" title="2）约束的种类"></a>2）约束的种类</h3><p>​       <strong>（1）非空约束：not null</strong><br>​       <strong>（2）唯一性约束： unique</strong><br>​                唯一性约束条件用于保证字段不出现重复值，当给表的某个列定义了唯一约束条件，<br>​                该列的值不允许重复<em>，但是允许是null值。</em><br>​       <strong>（3）主键约束： primary key</strong><br>​                主键约束条件从功能上看相当于是非空约束且唯一约束的组合。<br>​                一个表上只允许建立一个主键，而其它约束条件则没有明确的个数限制<br>​       <strong>（4）检查约束： check</strong><br>​                检查约束条件用来强制在字段上的每个值都要满足check中定义的条件。<br>​     </p><pre class=" language-sql"><code class="language-sql">  SQL<span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">create</span> <span class="token keyword">table</span> teacher<span class="token punctuation">(</span>                         id number<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>                         name varchar2<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>                         card number<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token keyword">unique</span><span class="token punctuation">,</span>                         age number<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">check</span><span class="token punctuation">(</span>age<span class="token operator">></span><span class="token number">30</span><span class="token punctuation">)</span>                  <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>sql语句的编写顺序：<br><em>SQL语句的编写顺序：select —-from—- where—- group by —-having —-order by?</em></p><p>sql语句的执行顺序：<br><em>SQL语句的执行顺序：from—–where——group by——having —-select—–order by</em></p><p>执行顺序：</p><p>1.from<br>?????? 先选择一个表，或者说源头，构成一个结果集。<br>2.where<br>?????? 然后用where对结果集进行筛选。筛选出需要的信息形成新的结果集。<br>3.group by<br>?????? 对新的结果集分组。<br>4.having<br>????? 筛选出想要的分组。<br>5.select<br>???? 选择列。<br>6.order by<br>? ? ?最后完成排序。</p><p>创建表 default create table 还有命名规则 不能使用相同的表名和相同列名</p><p>查看表结构 DESC+表名   默认值重点，修改表名，增加列，删除列（删除多个字段加逗号），修改列，清除表数据，增删该查  事物控制语言TCL 提交数据，数据回滚，savepoint保存点，update insert delete char 型 各种类型要知道,DESC语句，truncate直接删除表的所有数据和delete的区别，每个表中只能有一个long型</p><p>字符串函数一定要记得 length返回字符串长度</p><p>补位函数 nvl函数</p><p>​                     </p><p>​          </p><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉平衡树</title>
      <link href="/2018/11/07/2018-03-26-er-cha-ping-heng-shu/"/>
      <url>/2018/11/07/2018-03-26-er-cha-ping-heng-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h3><p>平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。</p><p>平衡二叉树大部分操作和二叉查找树类似，主要不同在于插入删除的时候平衡二叉树的平衡可能被改变，并且只有从那些插入点到根结点的路径上的结点的平衡性可能被改变，因为只有这些结点的子树可能变化。</p><p>平衡二叉树不平衡的情形：</p><p>把需要重新平衡的结点叫做α，由于任意两个结点最多只有两个儿子，因此高度不平衡时，α结点的两颗子树的高度相差2.容易看出，这种不平衡可能出现在下面4中情况中：</p><p>1.对α的左儿子的左子树进行一次插入</p><p>2.对α的左儿子的右子树进行一次插入</p><p>3.对α的右儿子的左子树进行一次插入</p><p>4.对α的右儿子的右子树进行一次插入</p><p>情形1和情形4是关于α的镜像对称，二情形2和情形3也是关于α的镜像对称，因此理论上看只有两种情况，但编程的角度看还是四种情形。</p><p>第一种情况是插入发生在“外边”的情形（左左或右右），该情况可以通过一次单旋转完成调整；第二种情况是插入发生在“内部”的情形（左右或右左），这种情况比较复杂，需要通过双旋转来调整。</p><h3 id="调整措施："><a href="#调整措施：" class="headerlink" title="调整措施："></a>调整措施：</h3><h3 id="一、单旋转"><a href="#一、单旋转" class="headerlink" title="一、单旋转"></a>一、单旋转</h3><p>上图是左左的情况，k2结点不满足平衡性，它的左子树k1比右子树z深两层，k1子树中更深的是k1的左子树x，因此属于左左情况。</p><p>为了恢复平衡，我们把x上移一层，并把z下移一层，但此时实际已经超出了AVL树的性质要求。为此，重新安排结点以形成一颗等价的树。为使树恢复平衡，我们把k2变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。</p><p>这种情况称为单旋转。</p><h3 id="二、双旋转"><a href="#二、双旋转" class="headerlink" title="二、双旋转"></a>二、双旋转</h3><p>对于左右和右左两种情况，单旋转不能解决问题，要经过两次旋转。</p><p>对于上图情况，为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树。</p><p>AVL树的删除操作：</p><p>同插入操作一样，删除结点时也有可能破坏平衡性，这就要求我们删除的时候要进行平衡性调整。</p><p>删除分为以下几种情况：</p><p>首先在整个二叉树中搜索要删除的结点，如果没搜索到直接返回不作处理，否则执行以下操作：</p><h3 id="1-要删除的节点是当前根节点T。"><a href="#1-要删除的节点是当前根节点T。" class="headerlink" title="1.要删除的节点是当前根节点T。"></a>1.要删除的节点是当前根节点T。</h3><p>如果左右子树都非空。在高度较大的子树中实施删除操作。</p><p>分两种情况：</p><p>(1)、左子树高度大于右子树高度，将左子树中最大的那个元素赋给当前根节点，然后删除左子树中元素值最大的那个节点。</p><p>(1)、左子树高度小于右子树高度，将右子树中最小的那个元素赋给当前根节点，然后删除右子树中元素值最小的那个节点。</p><p>如果左右子树中有一个为空，那么直接用那个非空子树或者是NULL替换当前根节点即可。</p><h3 id="2、要删除的节点元素值小于当前根节点T值，在左子树中进行删除。"><a href="#2、要删除的节点元素值小于当前根节点T值，在左子树中进行删除。" class="headerlink" title="2、要删除的节点元素值小于当前根节点T值，在左子树中进行删除。"></a>2、要删除的节点元素值小于当前根节点T值，在左子树中进行删除。</h3><p>递归调用，在左子树中实施删除。</p><p>这个是需要判断当前根节点是否仍然满足平衡条件，</p><p>如果满足平衡条件，只需要更新当前根节点T的高度信息。</p><p>否则，需要进行旋转调整：</p><p>如果T的左子节点的左子树的高度大于T的左子节点的右子树的高度，进行相应的单旋转。否则进行双旋转。</p><h3 id="3、要删除的节点元素值大于当前根节点T值，在右子树中进行删除。"><a href="#3、要删除的节点元素值大于当前根节点T值，在右子树中进行删除。" class="headerlink" title="3、要删除的节点元素值大于当前根节点T值，在右子树中进行删除。"></a>3、要删除的节点元素值大于当前根节点T值，在右子树中进行删除。</h3><h3 id="下面给出详细代码实现："><a href="#下面给出详细代码实现：" class="headerlink" title="下面给出详细代码实现："></a>下面给出详细代码实现：</h3><p>AvlTree.h</p><pre class=" language-c++"><code class="language-c++">  1 #include <iostream>  2 #include <algorithm>  3 using namespace std;  4 #pragma once  5   6 //平衡二叉树结点  7 template <typename T>  8 struct AvlNode  9 { 10     T data; 11     int height; //结点所在高度 12     AvlNode<T> *left; 13     AvlNode<T> *right; 14     AvlNode<T>(const T theData) : data(theData), left(NULL), right(NULL), height(0){} 15 }; 16  17 //AvlTree 18 template <typename T> 19 class AvlTree 20 { 21 public: 22     AvlTree<T>(){} 23     ~AvlTree<T>(){} 24     AvlNode<T> *root; 25     //插入结点 26     void Insert(AvlNode<T> *&t, T x); 27     //删除结点 28     bool Delete(AvlNode<T> *&t, T x); 29     //查找是否存在给定值的结点 30     bool Contains(AvlNode<T> *t, const T x) const; 31     //中序遍历 32     void InorderTraversal(AvlNode<T> *t); 33     //前序遍历 34     void PreorderTraversal(AvlNode<T> *t); 35     //最小值结点 36     AvlNode<T> *FindMin(AvlNode<T> *t) const; 37     //最大值结点 38     AvlNode<T> *FindMax(AvlNode<T> *t) const; 39 private: 40     //求树的高度 41     int GetHeight(AvlNode<T> *t); 42     //单旋转 左 43     AvlNode<T> *LL(AvlNode<T> *t); 44     //单旋转 右 45     AvlNode<T> *RR(AvlNode<T> *t); 46     //双旋转 右左 47     AvlNode<T> *LR(AvlNode<T> *t); 48     //双旋转 左右 49     AvlNode<T> *RL(AvlNode<T> *t); 50 }; 51  52 template <typename T> 53 AvlNode<T> * AvlTree<T>::FindMax(AvlNode<T> *t) const 54 { 55     if (t == NULL) 56         return NULL; 57     if (t->right == NULL) 58         return t; 59     return FindMax(t->right); 60 } 61  62 template <typename T> 63 AvlNode<T> * AvlTree<T>::FindMin(AvlNode<T> *t) const 64 { 65     if (t == NULL) 66         return NULL; 67     if (t->left == NULL) 68         return t; 69     return FindMin(t->left); 70 } 71  72  73 template <typename T> 74 int AvlTree<T>::GetHeight(AvlNode<T> *t) 75 { 76     if (t == NULL) 77         return -1; 78     else 79         return t->height; 80 } 81  82  83 //单旋转 84 //左左插入导致的不平衡 85 template <typename T> 86 AvlNode<T> * AvlTree<T>::LL(AvlNode<T> *t) 87 { 88     AvlNode<T> *q = t->left; 89     t->left = q->right; 90     q->right = t; 91     t = q; 92     t->height = max(GetHeight(t->left), GetHeight(t->right)) + 1; 93     q->height = max(GetHeight(q->left), GetHeight(q->right)) + 1; 94     return q; 95 } 96  97 //单旋转 98 //右右插入导致的不平衡 99 template <typename T>100 AvlNode<T> * AvlTree<T>::RR(AvlNode<T> *t)101 {102     AvlNode<T> *q = t->right;103     t->right = q->left;104     q->left = t;105     t = q;106     t->height = max(GetHeight(t->left), GetHeight(t->right)) + 1;107     q->height = max(GetHeight(q->left), GetHeight(q->right)) + 1;108     return q;109 }110 111 //双旋转 112 //插入点位于t的左儿子的右子树113 template <typename T>114 AvlNode<T> * AvlTree<T>::LR(AvlNode<T> *t)115 {116     //双旋转可以通过两次单旋转实现117     //对t的左结点进行RR旋转，再对根节点进行LL旋转118     RR(t->left);119     return LL(t);120 }121 122 //双旋转123 //插入点位于t的右儿子的左子树124 template <typename T>125 AvlNode<T> * AvlTree<T>::RL(AvlNode<T> *t)126 {127     LL(t->right);128     return RR(t);129 }130 131 132 template <typename T>133 void AvlTree<T>::Insert(AvlNode<T> *&t, T x)134 {135     if (t == NULL)136         t = new AvlNode<T>(x);137     else if (x < t->data)138     {139         Insert(t->left, x);140         //判断平衡情况141         if (GetHeight(t->left) - GetHeight(t->right) > 1)142         {143             //分两种情况 左左或左右144 145             if (x < t->left->data)//左左146                 t = LL(t);147             else                  //左右148                 t = LR(t);149         }150     }151     else if (x > t->data)152     {153         Insert(t->right, x);154         if (GetHeight(t->right) - GetHeight(t->left) > 1)155         {156             if (x > t->right->data)157                 t = RR(t);158             else159                 t = RL(t);160         }161     }162     else163         ;//数据重复164     t->height = max(GetHeight(t->left), GetHeight(t->right)) + 1;165 }166 167 template <typename T>168 bool AvlTree<T>::Delete(AvlNode<T> *&t, T x)169 {170     //t为空 未找到要删除的结点171     if (t == NULL)172         return false;173     //找到了要删除的结点174     else if (t->data == x)175     {176         //左右子树都非空177         if (t->left != NULL && t->right != NULL)178         {//在高度更大的那个子树上进行删除操作179 180             //左子树高度大，删除左子树中值最大的结点，将其赋给根结点181             if (GetHeight(t->left) > GetHeight(t->right))182             {183                 t->data = FindMax(t->left)->data;184                 Delete(t->left, t->data);185             }186             else//右子树高度更大，删除右子树中值最小的结点，将其赋给根结点187             {188                 t->data = FindMin(t->right)->data;189                 Delete(t->right, t->data);190             }191         }192         else193         {//左右子树有一个不为空，直接用需要删除的结点的子结点替换即可194             AvlNode<T> *old = t;195             t = t->left ? t->left: t->right;//t赋值为不空的子结点196             delete old;197         }198     }199     else if (x < t->data)//要删除的结点在左子树上200     {201         //递归删除左子树上的结点202         Delete(t->left, x);203         //判断是否仍然满足平衡条件204         if (GetHeight(t->right) - GetHeight(t->left) > 1)205         {206             if (GetHeight(t->right->left) > GetHeight(t->right->right))207             {208                 //RL双旋转209                 t = RL(t);210             }211             else212             {//RR单旋转213                 t = RR(t);214             }215         }216         else//满足平衡条件 调整高度信息217         {218             t->height = max(GetHeight(t->left), GetHeight(t->right)) + 1;219         }220     }221     else//要删除的结点在右子树上222     {223         //递归删除右子树结点224         Delete(t->right, x);225         //判断平衡情况226         if (GetHeight(t->left) - GetHeight(t->right) > 1)227         {228             if (GetHeight(t->left->right) > GetHeight(t->left->left))229             {230                 //LR双旋转231                 t = LR(t);232             }233             else234             {235                 //LL单旋转236                 t = LL(t);237             }238         }239         else//满足平衡性 调整高度240         {241             t->height = max(GetHeight(t->left), GetHeight(t->right)) + 1;242         }243     }244     245     return true;246 }247 248 //查找结点249 template <typename T>250 bool AvlTree<T>::Contains(AvlNode<T> *t, const T x) const251 {252     if (t == NULL)253         return false;254     if (x < t->data)255         return Contains(t->left, x);256     else if (x > t->data)257         return Contains(t->right, x);258     else259         return true;260 }261 262 //中序遍历263 template <typename T>264 void AvlTree<T>::InorderTraversal(AvlNode<T> *t)265 {266     if (t)267     {268         InorderTraversal(t->left);269         cout << t->data << ' ';270         InorderTraversal(t->right);271     }272 }273 274 //前序遍历275 template <typename T>276 void AvlTree<T>::PreorderTraversal(AvlNode<T> *t)277 {278     if (t)279     {280         cout << t->data << ' ';281         PreorderTraversal(t->left);282         PreorderTraversal(t->right);283     }284 }main.cpp 1 #include "AvlTree.h" 2  3 int main() 4 { 5     AvlTree<int> tree; 6     int value; 7     int tmp; 8     cout << "请输入整数建立二叉树(-1结束)：" << endl; 9     while (cin >> value)10     {11         if (value == -1)12             break;13         tree.Insert(tree.root,value);14     }15     cout << "中序遍历";16     tree.InorderTraversal(tree.root);17     cout << "\n前序遍历:";18     tree.PreorderTraversal(tree.root);19     cout << "\n请输入要查找的结点：";20     cin >> tmp;21     if (tree.Contains(tree.root, tmp))22         cout << "已查找到" << endl;23     else24         cout << "值为" << tmp << "的结点不存在" << endl;25     cout << "请输入要删除的结点：";26     cin >> tmp;27     tree.Delete(tree.root, tmp);28     cout << "删除后的中序遍历：";29     tree.InorderTraversal(tree.root);30     cout << "\n删除后的前序遍历：";31     tree.PreorderTraversal(tree.root);32 }<br>引用自CSDN：https://www.cnblogs.com/zhangbaochong/p/5164994.html</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python视频推荐</title>
      <link href="/2018/11/07/2018-04-06-python-xue-xi-shi-pin-tui-jian/"/>
      <url>/2018/11/07/2018-04-06-python-xue-xi-shi-pin-tui-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="Python视频推荐"><a href="#Python视频推荐" class="headerlink" title="Python视频推荐"></a>Python视频推荐</h3><p> <strong><em>python开发桌面应用程序的框架可用的非常少，推荐bilibili上莫烦的教学视频讲的很细 <a href="https://space.bilibili.com/243821484/#/" target="_blank" rel="noopener">https://space.bilibili.com/243821484/#/</a>*</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你搭建SSM项目</title>
      <link href="/2018/10/11/shou-ba-shou-jiao-ni-da-jian-ssm-xiang-mu/"/>
      <url>/2018/10/11/shou-ba-shou-jiao-ni-da-jian-ssm-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h2 id="手把手教你搭建SSM项目"><a href="#手把手教你搭建SSM项目" class="headerlink" title="手把手教你搭建SSM项目"></a>手把手教你搭建SSM项目</h2><p>打开File-&gt;NEW -&gt;Maven Project</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g4327iyj18j30vx0kqdj7.jpg" alt="1555723865658"></p><p>选择默认存储空间，点击下一步</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g4328fk6c1j30lu0i7abe.jpg" alt="1555723977409"></p><p>选择创建的Maven类型，点击下一步</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g4328fk6c1j30lu0i7abe.jpg" alt="1555724147996"></p><p>填写类路径</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g4328fk6c1j30lu0i7abe.jpg" alt="1555724256164"></p><p>项目创建完了，在Package Explorer列显示</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g4328fk6c1j30lu0i7abe.jpg" alt="1555724378847"></p><p>出现这个错误很正常，那是因为我们还没有给项目添加Tomcat服务器</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g4328fk6c1j30lu0i7abe.jpg" alt="1555724500923"></p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g4328fk6c1j30lu0i7abe.jpg" alt="1555724702022"></p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g4328fk6c1j30lu0i7abe.jpg" alt="1555724728672"></p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g4328fk6c1j30lu0i7abe.jpg" alt="1555724806342"></p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g4328fk6c1j30lu0i7abe.jpg" alt="1555724824798"></p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432g6ngr1j30ye0l9dky.jpg" alt="1555724911740"></p><p>项目启动成功</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432hrcg5sj30sg0lc782.jpg" alt="1555725176028"></p><p>打开路径下的POM文件</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432jpcwnjj30sg0lc43h.jpg" alt="1555725263870"></p><p>我们用Maven形式导入jar包，百度搜索Maven 我们进入maven仓库进去查找我们需要的jar包</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432k2pbaij30ph0jggoc.jpg" alt="1555725475068"></p><p>我们以搜索MySQL为例</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432kpu32bj30oc0jpjuv.jpg" alt="1555725637596"></p><p>这里面就有我们想要的 jdbc 连接jar包，选择好自己想要的版本</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432l4o9hcj30o50kw41a.jpg" alt="1555725737046"></p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432lhkljij30z10ss12u.jpg" alt="1555725992641"></p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432luyst8j30tx0icgnj.jpg" alt="1555726102410"></p><p>我们已经看到负责数据库连接的Jar已经自动下载完成了，由于我们要完成的是SSM项目所有我们还要去复制几段依赖我这里就不一一赘述了。</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432m5wvfhj30j30eeta4.jpg" alt="1555726153260"></p><p>连续去终于那个仓库复制了 几个依赖以后可能会出现排版混乱的情况 我们用快捷键 Ctrl+Shift+F   </p><p>来重新排一下版</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432mo4c9oj30gb0bqq4j.jpg" alt="1555726569345"></p><p>我们创建一个数据库表</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432mxt2o8j30c20623yi.jpg" alt="1555727892833"></p><p>然后我们修改数据库时区</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432n8p0akj30g808o0ss.jpg" alt="1555832242131"></p><p>下一步我们创建实体类，并设置get和set方法</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432nijz8xj30sg0lc78q.jpg" alt="1555832416456"></p><p>创建Mapper接口（注意一点在导入List 的时候 注意看清之后再导入，否则很容易导入 awt.List,正确导入的应该是util.ist）</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432ntpg5vj30sg0lcn27.jpg" alt="1555833238452"></p><p>下面我们在Mapper.xml</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432o2sx3pj30tt0itwga.jpg" alt="1555834665605"></p><p>我们编写Userserevice接口文件</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432oef76aj30t70iedgj.jpg" alt="1555835118449"></p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432pwr6rbj30sv0i7myi.jpg" alt="1555835305040"></p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g432qgor82j30tz0iyabg.jpg" alt="1555835610210"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十种排序算法总结</title>
      <link href="/2018/09/07/shi-chong-pai-xu-suan-fa-zong-jie/"/>
      <url>/2018/09/07/shi-chong-pai-xu-suan-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><p>从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，每一轮循环下来找出剩余未排序数的中的最大数并”冒泡”至数列的顶端。</p><h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h3><p>（1）从数组中第一个数开始，依次与下一个数比较并次交换比自己小的数，直到最后一个数。如果发生交换，则继续下面的步骤，如果未发生交换，则数组有序，排序结束，此时时间复杂度为O(n)；<br>（2）每一轮”冒泡”结束后，最大的数将出现在乱序数列的最后一位。重复步骤（1）。</p><p>稳定性：稳定排序。</p><p>时间复杂度： O(n)至，平均时间复杂度为。</p><p>最好的情况：如果待排序数据序列为正序，则一趟冒泡就可完成排序，排序码的比较次数为n-1次，且没有移动，时间复杂度为O(n)。</p><p>最坏的情况：如果待排序数据序列为逆序，则冒泡排序需要n-1次趟起泡，每趟进行n-i次排序码的比较和移动，即比较和移动次数均达到最大值：<br>比较次数:<br>移动次数等于比较次数，因此最坏时间复杂度为。</p><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//循环的次数为数组长度减一，剩下的一个数不需要排序</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        bool noswap<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//循环次数为待排序数第一位数冒泡至最高位的比较次数</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//交换或者使用如下方式</span>                <span class="token comment" spellcheck="true">//a=a^b;</span>                <span class="token comment" spellcheck="true">//b=b^a;</span>                <span class="token comment" spellcheck="true">//a=a^b;</span>                noswap<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>noswap<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>12<br>34<br>56<br>78<br>910<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20</p><h3 id="2-1-2快速排序"><a href="#2-1-2快速排序" class="headerlink" title="2.1.2快速排序"></a>2.1.2快速排序</h3><p>冒泡排序是在相邻的两个记录进行比较和交换，每次交换只能上移或下移一个位置，导致总的比较与移动次数较多。快速排序又称分区交换排序，是对冒泡排序的改进，快速排序采用的思想是分治思想。。</p><p>算法原理：<br>(1)从待排序的n个记录中任意选取一个记录（通常选取第一个记录）为分区标准;</p><p>(2)把所有小于该排序列的记录移动到左边，把所有大于该排序码的记录移动到右边，中间放所选记录，称之为第一趟排序；</p><p>(3)然后对前后两个子序列分别重复上述过程，直到所有记录都排好序。</p><p>稳定性：不稳定排序。</p><p>时间复杂度： 至，平均时间复杂度为。</p><p>最好的情况：是每趟排序结束后，每次划分使两个子文件的长度大致相等，时间复杂度为。</p><p>最坏的情况：是待排序记录已经排好序，第一趟经过n-1次比较后第一个记录保持位置不变，并得到一个n-1个元素的子记录；第二趟经过n-2次比较，将第二个记录定位在原来的位置上，并得到一个包括n-2个记录的子文件，依次类推，这样总的比较次数是：<br>示例代码：</p><p>//a：待排序数组，low：最低位的下标，high：最高位的下标</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">>=</span>high<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> left<span class="token operator">=</span>low<span class="token punctuation">;</span>    <span class="token keyword">int</span> right<span class="token operator">=</span>high<span class="token punctuation">;</span>    <span class="token keyword">int</span> key<span class="token operator">=</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*用数组的第一个记录作为分区元素*/</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">!=</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">>=</span>key<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/*从右向左扫描，找第一个码值小于key的记录，并交换到key*/</span>            <span class="token operator">--</span>right<span class="token punctuation">;</span>        a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;=</span>key<span class="token punctuation">)</span>            <span class="token operator">++</span>left<span class="token punctuation">;</span>        a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*从左向右扫描，找第一个码值大于key的记录，并交换到右边*/</span>    <span class="token punctuation">}</span>    a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>key<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*分区元素放到正确位置*/</span>    <span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>low<span class="token punctuation">,</span>left<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>12<br>34<br>56<br>78<br>910<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>2.2插入类排序</p><p>12<br>34<br>56<br>78<br>910<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>2.2插入类排序</p><p>插入排序的基本方法是：每步将一个待排序的记录，按其排序码大小，插到前面已经排序的文件中的适当位置，直到全部插入完为止。</p><h3 id="2-2-1直接插入排序"><a href="#2-2-1直接插入排序" class="headerlink" title="2.2.1直接插入排序"></a>2.2.1直接插入排序</h3><p>原理：从待排序的n个记录中的第二个记录开始，依次与前面的记录比较并寻找插入的位置，每次外循环结束后，将当前的数插入到合适的位置。</p><p>稳定性：稳定排序。</p><p>时间复杂度： O(n)至，平均时间复杂度是。</p><p>最好情况：当待排序记录已经有序，这时需要比较的次数是。</p><p>最坏情况：如果待排序记录为逆序，则最多的比较次数为。</p><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//A：输入数组，len:数组长度</span><span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      temp<span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//查找到要插入的位置</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>temp<span class="token punctuation">)</span>      <span class="token punctuation">{</span>          A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>          j<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">!=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>12<br>34<br>56<br>78<br>910<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>2.2.2 Shell排序</p><p>Shell 排序又称缩小增量排序, 由D. L. Shell在1959年提出，是对直接插入排序的改进。</p><p>原理： Shell排序法是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。</p><p>Shell排序开始时增量较大，分组较多，每组的记录数目较少，故在各组内采用直接插入排序较快，后来增量逐渐缩小，分组数减少，各组的记录数增多，但由于已经按分组排序，文件叫接近于有序状态，所以新的一趟排序过程较快。因此Shell排序在效率上比直接插入排序有较大的改进。</p><p>在直接插入排序的基础上，将直接插入排序中的1全部改变成增量d即可，因为Shell排序最后一轮的增量d就为1。</p><p>稳定性：不稳定排序。</p><p>时间复杂度：到。Shell排序算法的时间复杂度分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。研究证明，若增量的取值比较合理，Shell排序算法的时间复杂度约为。</p><p>对于增量的选择，Shell 最初建议增量选择为n/2，并且对增量取半直到 1；D. Knuth教授建议序列。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//A：输入数组，len:数组长度，d:初始增量(分组数)</span><span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> inc<span class="token operator">=</span>d<span class="token punctuation">;</span>inc<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>inc<span class="token operator">/=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//循环的次数为增量缩小至1的次数</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>inc<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//循环的次数为第一个分组的第二个元素到数组的结束</span>            <span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span>inc<span class="token punctuation">;</span>            <span class="token keyword">int</span> temp<span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>temp<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                A<span class="token punctuation">[</span>j<span class="token operator">+</span>inc<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">=</span>j<span class="token operator">-</span>inc<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>j<span class="token operator">+</span>inc<span class="token punctuation">)</span><span class="token operator">!=</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//防止自我插入</span>                A<span class="token punctuation">[</span>j<span class="token operator">+</span>inc<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//插入记录</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>12<br>34<br>56<br>78<br>910<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>注意：从代码中可以看出，增量每次变化取前一次增量的一般，当增量d等于1时，shell排序就退化成了直接插入排序了。</p><h3 id="2-3选择类排序"><a href="#2-3选择类排序" class="headerlink" title="2.3选择类排序"></a>2.3选择类排序</h3><p>选择类排序的基本方法是：每步从待排序记录中选出排序码最小的记录，顺序放在已排序的记录序列的后面，知道全部排完。</p><h3 id="2-3-1简单选择排序（又称直接选择排序）"><a href="#2-3-1简单选择排序（又称直接选择排序）" class="headerlink" title="2.3.1简单选择排序（又称直接选择排序）"></a>2.3.1简单选择排序（又称直接选择排序）</h3><p>原理：从所有记录中选出最小的一个数据元素与第一个位置的记录交换；然后在剩下的记录当中再找最小的与第二个位置的记录交换，循环到只剩下最后一个数据元素为止。</p><p>稳定性：不稳定排序。</p><p>时间复杂度： 最坏、最好和平均复杂度均为，因此，简单选择排序也是常见排序算法中性能最差的排序算法。简单选择排序的比较次数与文件的初始状态没有关系，在第i趟排序中选出最小排序码的记录，需要做n-i次比较，因此总的比较次数是：。</p><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       k<span class="token operator">=</span>i<span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>               k<span class="token operator">=</span>j<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>           A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>           A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>           A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>12<br>34<br>56<br>78<br>910<br>11<br>12<br>13<br>14<br>15<br>16<br>2.3.2堆排序</p><p>直接选择排序中，第一次选择经过了n-1次比较，只是从排序码序列中选出了一个最小的排序码，而没有保存其他中间比较结果。所以后一趟排序时又要重复许多比较操作，降低了效率。J. Willioms和Floyd在1964年提出了堆排序方法，避免这一缺点。</p><p>堆的性质：<br>（1）性质：完全二叉树或者是近似完全二叉树；<br>（2）分类：大顶堆：父节点不小于子节点键值，小顶堆：父节点不大于子节点键值；图展示一个最小堆：<br>这里写图片描述</p><p>（3）左右孩子：没有大小的顺序。</p><h3 id="（4）堆的存储"><a href="#（4）堆的存储" class="headerlink" title="（4）堆的存储"></a>（4）堆的存储</h3><p>一般都用数组来存储堆，i结点的父结点下标就为。它的左右子结点下标分别为  和 。如第0个结点左右子结点下标分别为1和2。<br>这里写图片描述</p><h3 id="（5）堆的操作"><a href="#（5）堆的操作" class="headerlink" title="（5）堆的操作"></a>（5）堆的操作</h3><p>建立：<br>以最小堆为例，如果以数组存储元素时，一个数组具有对应的树表示形式，但树并不满足堆的条件，需要重新排列元素，可以建立“堆化”的树。</p><p>这里写图片描述</p><p>插入：<br>将一个新元素插入到表尾，即数组末尾时，如果新构成的二叉树不满足堆的性质，需要重新排列元素，下图演示了插入15时，堆的调整。</p><p>这里写图片描述</p><p>删除：<br>堆排序中，删除一个元素总是发生在堆顶，因为堆顶的元素是最小的（小顶堆中）。表中最后一个元素用来填补空缺位置，结果树被更新以满足堆条件。</p><p>这里写图片描述</p><p>稳定性：不稳定排序。</p><p>插入代码实现：<br>每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中，这就类似于直接插入排序中将一个数据并入到有序区间中，这是节点“上浮”调整。不难写出插入一个新数据时堆的调整代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//新加入i结点,其父结点为(i-1)/2</span><span class="token comment" spellcheck="true">//参数：a：数组，i：新插入元素在数组中的下标  </span><span class="token keyword">void</span> <span class="token function">minHeapFixUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">int</span> j<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>      temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      j <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//父结点  </span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temp<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果父节点不大于新插入的元素，停止寻找  </span>            <span class="token keyword">break</span><span class="token punctuation">;</span>          a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//把较大的子结点往下移动,替换它的子结点  </span>        i <span class="token operator">=</span> j<span class="token punctuation">;</span>          j <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre><p>12<br>34<br>56<br>78<br>910<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>因此，插入数据到最小堆时：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//在最小堆中加入新的数据data  </span><span class="token comment" spellcheck="true">//a：数组，index：插入的下标，</span><span class="token keyword">void</span> <span class="token function">minHeapAddNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      a<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>      <span class="token function">minHeapFixUp</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> </code></pre><p>12<br>34<br>56<br>7删除代码实现：<br>按定义，堆中每次都只能删除第0个数据。为了便于重建堆，实际的操作是将数组最后一个数据与根结点，然后再从根结点开始进行一次从上向下的调整。</p><p>调整时先在左右儿子结点中找最小的，如果父结点不大于这个最小的子结点说明不需要调整了，反之将最小的子节点换到父结点的位置。此时父节点实际上并不需要换到最小子节点的位置，因为这不是父节点的最终位置。但逻辑上父节点替换了最小的子节点，然后再考虑父节点对后面的结点的影响。相当于从根结点将一个数据的“下沉”过程。下面给出代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//a为数组，从index节点开始调整,len为节点总数 从0开始计算index节点的子节点为 2*index+1, 2*index+2,len/2-1为最后一个非叶子节点  </span><span class="token keyword">void</span> <span class="token function">minHeapFixDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">></span><span class="token punctuation">(</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//index为叶子节点不用调整</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tmp<span class="token operator">=</span>a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> lastIndex<span class="token operator">=</span>index<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">&lt;=</span><span class="token punctuation">(</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//当下沉到叶子节点时，就不用调整了</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>tmp<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果左子节点大于该节点</span>            lastIndex <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果存在右子节点且大于左子节点和该节点</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">2</span><span class="token operator">&lt;</span>len <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>tmp<span class="token punctuation">)</span>            lastIndex <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>index<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>lastIndex<span class="token operator">!=</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//如果左右子节点有一个小于该节点则设置该节点的下沉位置</span>            a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>            index<span class="token operator">=</span>lastIndex<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//否则该节点不用下沉调整</span>    <span class="token punctuation">}</span>    a<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将该节点放到最后的位置</span><span class="token punctuation">}</span></code></pre><p>12<br>34<br>56<br>78<br>910<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>根据思想，可以有不同版本的代码实现，以上是和孙凛同学一起讨论出的一个版本，在这里感谢他的参与，读者可另行给出。个人体会，这里建议大家根据对堆调整的过程的理解，写出自己的代码，切勿看示例代码去理解算法，而是理解算法思想写出代码，否则很快就会忘记。</p><p>建堆：<br>有了堆的插入和删除后，再考虑下如何对一个数据进行堆化操作。要一个一个的从数组中取出数据来建立堆吧，不用！先看一个数组，如下图：</p><p>这里写图片描述</p><p>很明显，对叶子结点来说，可以认为它已经是一个合法的堆了即20，60， 65， 4， 49都分别是一个合法的堆。只要从A[4]=50开始向下调整就可以了。然后再取A[3]=30，A[2] = 17，A[1] = 12，A[0] = 9分别作一次向下调整操作就可以了。下图展示了这些步骤：</p><p>这里写图片描述</p><p>写出堆化数组的代码：</p><p>//建立最小堆</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//a:数组，n：数组长度</span><span class="token keyword">void</span> <span class="token function">makeMinHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>          <span class="token function">minHeapFixDown</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre><p>12<br>34<br>56<br>7</p><p>12<br>34<br>56<br>7</p><h3 id="（6）堆排序的实现"><a href="#（6）堆排序的实现" class="headerlink" title="（6）堆排序的实现"></a>（6）堆排序的实现</h3><p>由于堆也是用数组来存储的，故对数组进行堆化后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n – 2]交换，再对A[0…n - 3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。有点类似于直接选择排序。</p><p>因此，完成堆排序并没有用到前面说明的插入操作，只用到了建堆和节点向下调整的操作，堆排序的操作如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//array:待排序数组，len：数组长度</span><span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//建堆</span>    <span class="token function">makeMinHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//根节点和最后一个叶子节点交换，并进行堆调整，交换的次数为len-1次</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//根节点和最后一个叶子节点交换</span>        array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> array<span class="token punctuation">[</span>len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          array<span class="token punctuation">[</span>len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>array<span class="token punctuation">[</span>len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>array<span class="token punctuation">[</span>len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>```    <span class="token comment" spellcheck="true">//堆调整</span>    <span class="token function">minHeapFixDown</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>```<span class="token punctuation">}</span>  </code></pre><p>12<br>34<br>56<br>78<br>910<br>11<br>12<br>13<br>14<br>15</p><h3 id="（7）堆排序的性能分析"><a href="#（7）堆排序的性能分析" class="headerlink" title="（7）堆排序的性能分析"></a>（7）堆排序的性能分析</h3><p>由于每次重新恢复堆的时间复杂度为O(logN)，共N - 1次堆调整操作，再加上前面建立堆时N / 2次向下调整，每次调整时间复杂度也为O(logN)。两次次操作时间相加还是O(N * logN)。故堆排序的时间复杂度为O(N * logN)。</p><p>最坏情况：如果待排序数组是有序的，仍然需要O(N * logN)复杂度的比较操作，只是少了移动的操作；</p><p>最好情况：如果待排序数组是逆序的，不仅需要O(N * logN)复杂度的比较操作，而且需要O(N * logN)复杂度的交换操作。总的时间复杂度还是O(N * logN)。</p><p>因此，堆排序和快速排序在效率上是差不多的，但是堆排序一般优于快速排序的重要一点是，数据的初始分布情况对堆排序的效率没有大的影响。</p><h3 id="2-4归并排序"><a href="#2-4归并排序" class="headerlink" title="2.4归并排序"></a>2.4归并排序</h3><p>算法思想：<br>归并排序属于比较类非线性时间排序，号称比较类排序中性能最佳者，在数据中应用中较广。</p><p>归并排序是分治法（Divide and Conquer）的一个典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>稳定性：稳定排序算法；</p><p>时间复杂度: 最坏，最好和平均时间复杂度都是Θ(nlgn)。</p><p>具体的实现见本人的另一篇blog：二路归并排序简介及其并行化。</p><h3 id="2-5线性时间非比较类排序"><a href="#2-5线性时间非比较类排序" class="headerlink" title="2.5线性时间非比较类排序"></a>2.5线性时间非比较类排序</h3><h3 id="2-5-1计数排序"><a href="#2-5-1计数排序" class="headerlink" title="2.5.1计数排序"></a>2.5.1计数排序</h3><p>计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出，它的优势在于在对于较小范围内的整数排序。它的复杂度为Ο(n+k)（其中k是待排序数的范围），快于任何比较排序算法，缺点就是非常消耗空间。很明显，如果而且当O(k)&gt;O(n*log(n))的时候其效率反而不如基于比较的排序，比如堆排序和归并排序和快速排序。</p><p>算法原理：<br>基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，在代码中作适当的修改即可。</p><p>算法步骤：<br>（1）找出待排序的数组中最大的元素；<br>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p><p>时间复杂度：Ο(n+k)。</p><p>空间复杂度：Ο(k)。</p><p>要求：待排序数中最大数值不能太大。</p><p>稳定性：稳定。</p><p>代码示例：</p><pre class=" language-java"><code class="language-java">#define MAXNUM <span class="token number">20</span>    <span class="token comment" spellcheck="true">//待排序数的最大个数</span>#define MAX    <span class="token number">100</span>   <span class="token comment" spellcheck="true">//待排序数的最大值</span><span class="token keyword">int</span> sorted_arr<span class="token punctuation">[</span>MAXNUM<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//计算排序</span><span class="token comment" spellcheck="true">//arr:待排序数组，sorted_arr：排好序的数组，n：待排序数组长度</span><span class="token keyword">void</span> <span class="token function">countSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>sorted_arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>  <span class="token punctuation">{</span>       <span class="token keyword">int</span> i<span class="token punctuation">;</span>       <span class="token keyword">int</span> <span class="token operator">*</span>count_arr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>MAX<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//初始化计数数组   </span><span class="token function">memset</span><span class="token punctuation">(</span>count_arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>MAX<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//统计i的次数   </span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>      count_arr<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//对所有的计数累加，作用是统计arr数组值和小于小于arr数组值出现的个数</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>      count_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count_arr<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//逆向遍历源数组（保证稳定性），根据计数数组中对应的值填充到新的数组中   </span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//count_arr[arr[i]]表示arr数组中包括arr[i]和小于arr[i]的总数</span>    sorted_arr<span class="token punctuation">[</span>count_arr<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//如果arr数组中有相同的数，arr[i]的下标减一</span>    count_arr<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token function">free</span><span class="token punctuation">(</span>count_arr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>}1<br>23<br>45<br>67<br>89<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>注意：计数排序是典型的以空间换时间的排序算法，对待排序的数据有严格的要求，比如待排序的数值中包含负数，最大值都有限制，请谨慎使用。</p><h3 id="2-5-2基数排序"><a href="#2-5-2基数排序" class="headerlink" title="2.5.2基数排序"></a>2.5.2基数排序</h3><p>基数排序属于“分配式排序”（distribution sort），是非比较类线性时间排序的一种，又称“桶子法”（bucket sort）。顾名思义，它是透过键值的部分信息，将要排序的元素分配至某些“桶”中，藉以达到排序的作用。</p><p>具体描述即代码示例见本人另一篇blog:基数排序简介及其并行化。</p><h3 id="2-5-3桶排序"><a href="#2-5-3桶排序" class="headerlink" title="2.5.3桶排序"></a>2.5.3桶排序</h3><p>桶排序也是分配排序的一种，但其是基于比较排序的，这也是与基数排序最大的区别所在。</p><p>思想：桶排序算法想法类似于散列表。首先要假设待排序的元素输入符合某种均匀分布，例如数据均匀分布在[ 0,1）区间上，则可将此区间划分为10个小区间，称为桶，对散布到同一个桶中的元素再排序。</p><p>要求：待排序数长度一致。</p><p>排序过程：<br>（1）设置一个定量的数组当作空桶子；<br>（2）寻访序列，并且把记录一个一个放到对应的桶子去；<br>（3）对每个不是空的桶子进行排序。<br>（4）从不是空的桶子里把项目再放回原来的序列中。</p><p>例如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序。</p><p>时间复杂度：<br>对N个关键字进行桶排序的时间复杂度分为两个部分：<br>(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。</p><p>(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，对于N个待排数据，M个桶，平均每个桶[N/M]个数据，则桶内排序的时间复杂度为  。其中 为第i个桶的数据量。</p><p>因此，平均时间复杂度为线性的O(N+C)，C为桶内排序所花费的时间。当每个桶只有一个数，则最好的时间复杂度为：O(N)。</p><p>示例代码：</p><pre class=" language-java"><code class="language-java">typedef struct node <span class="token punctuation">{</span>      <span class="token keyword">int</span> keyNum<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//桶中数的数量</span>     <span class="token keyword">int</span> key<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//存储的元素</span>     struct node <span class="token operator">*</span> next<span class="token punctuation">;</span>   <span class="token punctuation">}</span>KeyNode<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//keys待排序数组，size数组长度，bucket_size桶的数量</span> <span class="token keyword">void</span> <span class="token function">inc_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> keys<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">,</span><span class="token keyword">int</span> bucket_size<span class="token punctuation">)</span> <span class="token punctuation">{</span>      KeyNode<span class="token operator">*</span> k<span class="token operator">=</span><span class="token punctuation">(</span>KeyNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span>KeyNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于控制打印</span>     <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>b<span class="token punctuation">;</span>     KeyNode <span class="token operator">*</span><span class="token operator">*</span>bucket_table<span class="token operator">=</span><span class="token punctuation">(</span>KeyNode <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>bucket_size<span class="token operator">*</span><span class="token function">sizeof</span><span class="token punctuation">(</span>KeyNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>bucket_size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>           bucket_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>KeyNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span>KeyNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          bucket_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span>keyNum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录当前桶中是否有数据</span>         bucket_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//记录当前桶中的数据  </span>         bucket_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>NULL<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    </code></pre><pre class=" language-java"><code class="language-java"> <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index<span class="token punctuation">;</span>     KeyNode <span class="token operator">*</span>p<span class="token punctuation">;</span>     KeyNode <span class="token operator">*</span>node<span class="token operator">=</span><span class="token punctuation">(</span>KeyNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span>KeyNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        node<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">=</span>keys<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>       node<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>NULL<span class="token punctuation">;</span>       index<span class="token operator">=</span>keys<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//映射函数计算桶号  </span>     p<span class="token operator">=</span>bucket_table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//初始化P成为桶中数据链表的头指针  </span>     <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>keyNum<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//该桶中还没有数据 </span>     <span class="token punctuation">{</span>             bucket_table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>node<span class="token punctuation">;</span>             <span class="token punctuation">(</span>bucket_table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span>keyNum<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//桶的头结点记录桶内元素各数，此处加一</span>     <span class="token punctuation">}</span>     <span class="token keyword">else</span><span class="token comment" spellcheck="true">//该桶中已有数据 </span>     <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//链表结构的插入排序 </span>         <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">!=</span>NULL<span class="token operator">&amp;&amp;</span>p<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>key<span class="token operator">&lt;=</span>node<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span>                p<span class="token operator">=</span>p<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>             node<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>p<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>              p<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">=</span>node<span class="token punctuation">;</span>               <span class="token punctuation">(</span>bucket_table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span>keyNum<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//打印结果</span> <span class="token keyword">for</span><span class="token punctuation">(</span>b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>b<span class="token operator">&lt;</span>bucket_size<span class="token punctuation">;</span>b<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//判断条件是跳过桶的头结点，桶的下个节点为元素节点不为空</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span>bucket_table<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>k<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">!=</span>NULL<span class="token punctuation">;</span>k<span class="token operator">=</span>k<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span>       <span class="token punctuation">{</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>k<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><p> }</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet获取JSP表单内容</title>
      <link href="/2018/09/07/servlet-huo-qu-jsp-biao-dan-nei-rong/"/>
      <url>/2018/09/07/servlet-huo-qu-jsp-biao-dan-nei-rong/</url>
      
        <content type="html"><![CDATA[<h3 id="JSP提交表单简单方式不含复选框部分"><a href="#JSP提交表单简单方式不含复选框部分" class="headerlink" title="JSP提交表单简单方式不含复选框部分"></a>JSP提交表单简单方式不含复选框部分</h3><pre class=" language-javascript"><code class="language-javascript">  <span class="token operator">&lt;</span>form action<span class="token operator">=</span><span class="token string">"./servlet/Check"</span> method<span class="token operator">=</span><span class="token string">"post"</span><span class="token operator">></span>  name<span class="token punctuation">:</span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> name<span class="token operator">=</span><span class="token string">"username"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>br<span class="token operator">/</span><span class="token operator">></span>  pawd<span class="token punctuation">:</span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"password"</span> name<span class="token operator">=</span><span class="token string">"pwd"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>br<span class="token operator">/</span><span class="token operator">></span>  <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"hidden"</span> value<span class="token operator">=</span><span class="token string">"隐藏"</span> <span class="token operator">/</span><span class="token operator">></span>  <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"submit"</span> value<span class="token operator">=</span><span class="token string">"submit"</span><span class="token operator">/</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">></span></code></pre><h3 id="接着在就是获取以上的值"><a href="#接着在就是获取以上的值" class="headerlink" title="接着在就是获取以上的值"></a>接着在就是获取以上的值</h3><pre class=" language-java"><code class="language-java">PrintWriter out <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> String u <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> String p <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"pwd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String hd<span class="token operator">=</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"hidden"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出用户名</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSP </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC连接数据库</title>
      <link href="/2018/09/07/2018-01-26-jdbc-an-zhuang-ji-huan-jing-bian-liang-pei-zhi/"/>
      <url>/2018/09/07/2018-01-26-jdbc-an-zhuang-ji-huan-jing-bian-liang-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h3>JDBC安装中出现的问题解决办法</h3>首先下载安装Microsoft公司提供的JDBC Driver For MSSQL2000,安装完成后，鼠标右击[我的电脑]-弹出菜单中选择[属性]-弹出对话框中选择[高级]-点击[环境变量]，下面操作在[系统变量]中进行，如果系统变量已存在相同变量名且包含相同变量值，则跳过该步操作；如果系统变量已存在相同变量名但未包含相同变量值，则添加该变量值（用英文“;”隔开）；如果系统变量不存在相同变量名，则按如下操作——<p>[新建]变量名：JDBC_Home  变量值：<br>C:/Program Files/Microsoft SQL Server 2000 Driver for JDBC </p><p>[新建]变量名：ClassPath     变量值：<br>%JDBC_Home%/lib/msbase.jar;%JDBC_Home%/lib/mssqlserver.jar;%JDBC_Home%/lib/msutil.jar;<br>.;%JAVA_HOME%/lib;%JAVA_HOME%/lib/tools.jar<br>如果没安装过 JDBC驱动那么系统变量 JDBC_HOME 的操作应该是[新建]，而由于您安装JDK的时候新建过CLASSPATH变量则下步应该是编辑CLASSPATH变量名<br>最后重启计算机，完成JDBC配置。</p><p>补充：<br>建议将%JDBC_Home%/lib/msbase.jar;%JDBC_Home%/lib/mssqlserver.jar;%JDBC_Home%/lib/msutil.jar三个文件拷贝至%Java_Home%/jre/lib/ext目录下和%Tomcat_Home%/common/lib目录下。</p><p>最后我们写个JAVA文件来测试下。。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>gamvan<span class="token punctuation">.</span>conn<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConnClub</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> String gvDriver <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>     <span class="token keyword">private</span> String gvUser <span class="token operator">=</span> <span class="token string">"sa"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数据库登录用户</span>    <span class="token keyword">private</span> String gvPassword <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数据库登录密码</span>    <span class="token keyword">private</span> Statement sta<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String message <span class="token operator">=</span> <span class="token string">"恭喜，数据库连接正常！"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Connection <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.microsoft.jdbc.sqlserver.SQLServerDriver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            gvDriver<span class="token operator">=</span><span class="token string">"jdbc:microsoft:sqlserver://127.0.0.1:1433;DatabaseName=GVclub"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>gvDriver<span class="token punctuation">,</span> gvUser<span class="token punctuation">,</span> gvPassword<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>            message <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ConnClub cc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnClub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Connection con <span class="token operator">=</span> cc<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br>引用：<a href="https://blog.csdn.net/u012410733/article/details/61619656" target="_blank" rel="noopener">https://blog.csdn.net/u012410733/article/details/61619656</a><br></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令总结</title>
      <link href="/2018/09/01/2018-04-03-linux-chang-yong-ming-ling/"/>
      <url>/2018/09/01/2018-04-03-linux-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>掌握一下20个命令可以应付Linux日常使用了，个人认为现阶段如果不是专门去学这一门课，学太多的命令是很快就会忘记的，上学期学的命令现在想想已经是很模糊了。</p><h3 id="1、cd命令"><a href="#1、cd命令" class="headerlink" title="1、cd命令"></a>1、cd命令</h3><p>这是一个非常基本，也是大家经常需要使用的命令，它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。如：</p><p>[html] view plain copy</p><pre><code>cd /root/Docements # 切换到目录/root/Docements  cd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录    cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录  </code></pre><h3 id="2、ls命令"><a href="#2、ls命令" class="headerlink" title="2、ls命令"></a>2、ls命令</h3><p>这是一个非常有用的查看文件与目录的命令，list之意，它的参数非常多，下面就列出一些我常用的参数吧，如下：</p><p>[html] view plain copy<br><em>-l ：列出长数据串，包含文件的属性与权限数据等<br>-a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）<br>-d ：仅列出目录本身，而不是列出目录的文件数据<br>-h ：将文件容量以较易读的方式（GB，kB等）列出来<br>-R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来</em>  </p><p><em>注：这些参数也可以组合使用，下面举两个例子：</em></p><p>[html] view plain copy<br>ls -l #以长数据串的形式列出当前目录下的数据文件和目录<br>ls -lR #以长数据串的形式列出当前目录下的所有文件  </p><h3 id="3、grep命令"><a href="#3、grep命令" class="headerlink" title="3、grep命令"></a>3、grep命令</h3><p>该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，它的简单语法为</p><p>[html] view plain copy<br>grep [-acinv] [–color=auto] ‘查找字符串’ filename  </p><p>它的常用参数如下：</p><p>[html] view plain copy<br>-a ：将binary文件以text文件的方式查找数据<br>-c ：计算找到‘查找字符串’的次数<br>-i ：忽略大小写的区别，即把大小写视为相同<br>-v ：反向选择，即显示出没有‘查找字符串’内容的那一行  </p><h1 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h1><h1 id="取出文件-etc-man-config中包含MANPATH的行，并把找到的关键字加上颜色"><a href="#取出文件-etc-man-config中包含MANPATH的行，并把找到的关键字加上颜色" class="headerlink" title="取出文件/etc/man.config中包含MANPATH的行，并把找到的关键字加上颜色"></a>取出文件/etc/man.config中包含MANPATH的行，并把找到的关键字加上颜色</h1><p>grep –color=auto ‘MANPATH’ /etc/man.config  </p><h1 id="把ls-l的输出中包含字母file（不区分大小写）的内容输出"><a href="#把ls-l的输出中包含字母file（不区分大小写）的内容输出" class="headerlink" title="把ls -l的输出中包含字母file（不区分大小写）的内容输出"></a>把ls -l的输出中包含字母file（不区分大小写）的内容输出</h1><p>ls -l | grep -i file  </p><h3 id="4、find命令"><a href="#4、find命令" class="headerlink" title="4、find命令"></a>4、find命令</h3><p>find是一个基于查找的功能非常强大的命令，相对而言，它的使用也相对较为复杂，参数也比较多，所以在这里将给把它们分类列出，它的基本语法如下：</p><p>[html] view plain copy<br>find [PATH] [option] [action]  </p><h1 id="与时间有关的参数："><a href="#与时间有关的参数：" class="headerlink" title="与时间有关的参数："></a>与时间有关的参数：</h1><p>-mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；<br>-mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；<br>-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；<br>-newer file : 列出比file还要新的文件名  </p><h1 id="例如：-1"><a href="#例如：-1" class="headerlink" title="例如："></a>例如：</h1><p>find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件  </p><h1 id="与用户或用户组名有关的参数："><a href="#与用户或用户组名有关的参数：" class="headerlink" title="与用户或用户组名有关的参数："></a>与用户或用户组名有关的参数：</h1><p>-user name : 列出文件所有者为name的文件<br>-group name : 列出文件所属用户组为name的文件<br>-uid n : 列出文件所有者为用户ID为n的文件<br>-gid n : 列出文件所属用户组为用户组ID为n的文件  </p><h1 id="例如：-2"><a href="#例如：-2" class="headerlink" title="例如："></a>例如：</h1><p>find /home/ljianhui -user ljianhui # 在目录/home/ljianhui中找出所有者为ljianhui的文件  </p><h1 id="与文件权限及名称有关的参数："><a href="#与文件权限及名称有关的参数：" class="headerlink" title="与文件权限及名称有关的参数："></a>与文件权限及名称有关的参数：</h1><p>-name filename ：找出文件名为filename的文件<br>-size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件<br>-tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、<br>             目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；<br>-perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755；<br>-perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示<br>-perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示  </p><h1 id="例如：-3"><a href="#例如：-3" class="headerlink" title="例如："></a>例如：</h1><p>find / -name passwd # 查找文件名为passwd的文件<br>find . -perm 0755 # 查找当前目录中文件权限的0755的文件<br>find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte  </p><h3 id="5、cp命令"><a href="#5、cp命令" class="headerlink" title="5、cp命令"></a>5、cp命令</h3><p>该命令用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下，它的常用参数如下： </p><p>[html] view plain copy<br>-a ：将文件的特性一起复制<br>-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份<br>-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行<br>-r ：递归持续复制，用于目录的复制行为<br>-u ：目标文件与源文件有差异时才会复制<br>例如 ：</p><p>[html] view plain copy<br>cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2<br>cp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中  </p><h3 id="6、mv命令"><a href="#6、mv命令" class="headerlink" title="6、mv命令"></a>6、mv命令</h3><p>该命令用于移动文件、目录或更名，move之意，它的常用参数如下：</p><p>[html] view plain copy<br>-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖<br>-i ：若目标文件已经存在，就会询问是否覆盖<br>-u ：若目标文件已经存在，且比目标文件新，才会更新  </p><p>注：该命令可以把一个文件或多个文件一次移动一个文件夹中，但是最后一个目标文件一定要是“目录”。</p><p>例如：</p><p>[html] view plain copy<br>mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中<br>mv file1 file2 # 把文件file1重命名为file2  </p><h3 id="7、rm命令"><a href="#7、rm命令" class="headerlink" title="7、rm命令"></a>7、rm命令</h3><p>该命令用于删除文件或目录，remove之间，它的常用参数如下：</p><p>[html] view plain copy<br>-f ：就是force的意思，忽略不存在的文件，不会出现警告消息<br>-i ：互动模式，在删除前会询问用户是否操作<br>-r ：递归删除，最常用于目录删除，它是一个非常危险的参数  </p><p>例如：</p><p>[html] view plain copy<br>rm -i file # 删除文件file，在删除之前会询问是否进行该操作<br>rm -fr dir # 强制删除目录dir中的所有文件  </p><h3 id="8、ps命令"><a href="#8、ps命令" class="headerlink" title="8、ps命令"></a>8、ps命令</h3><p>该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下：</p><p>[html] view plain copy<br>-A ：所有的进程均显示出来<br>-a ：不与terminal有关的所有进程<br>-u ：有效用户的相关进程<br>-x ：一般与a参数一起使用，可列出较完整的信息<br>-l ：较长，较详细地将PID的信息列出  </p><p>其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下：</p><p>[html] view plain copy<br>ps aux # 查看系统所有的进程数据<br>ps ax # 查看不与terminal有关的所有进程<br>ps -lA # 查看系统所有的进程数据<br>ps axjf # 查看连同一部分进程树状态  </p><h3 id="9、kill命令"><a href="#9、kill命令" class="headerlink" title="9、kill命令"></a>9、kill命令</h3><p>该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：</p><p>[html] view plain copy<br>kill -signal PID  </p><p>signal的常用参数如下：</p><p>注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号。</p><p>[html] view plain copy<br>1：SIGHUP，启动被终止的进程<br>2：SIGINT，相当于输入ctrl+c，中断一个程序的进行<br>9：SIGKILL，强制中断一个进程的进行<br>15：SIGTERM，以正常的结束进程方式来终止进程<br>17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行  </p><p>例如：</p><p>[html] view plain copy</p><h1 id="以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程"><a href="#以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程" class="headerlink" title="以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程"></a>以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程</h1><p>kill -SIGTERM %1   </p><h1 id="重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得"><a href="#重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得" class="headerlink" title="重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得"></a>重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得</h1><p>kill -SIGHUP PID  </p><h3 id="10、killall命令"><a href="#10、killall命令" class="headerlink" title="10、killall命令"></a>10、killall命令</h3><p>该命令用于向一个命令启动的进程发送一个信号，它的一般语法如下：</p><p>[html] view plain copy<br>killall [-iIe] [command name]  </p><p>它的参数如下：</p><p>[html] view plain copy<br>-i ：交互式的意思，若需要删除时，会询问用户<br>-e ：表示后面接的command name要一致，但command name不能超过15个字符<br>-I ：命令名称忽略大小写  </p><h1 id="例如：-4"><a href="#例如：-4" class="headerlink" title="例如："></a>例如：</h1><p>killall -SIGHUP syslogd # 重新启动syslogd  </p><h3 id="11、file命令"><a href="#11、file命令" class="headerlink" title="11、file命令"></a>11、file命令</h3><p>该命令用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用了，它的用法非常简单，基本语法如下：</p><p>[html] view plain copy<br>file filename  </p><p>#例如：<br>file ./test  </p><h3 id="12、tar命令"><a href="#12、tar命令" class="headerlink" title="12、tar命令"></a>12、tar命令</h3><p>该命令用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。它的常用参数如下：</p><p>[html] view plain copy<br>-c ：新建打包文件<br>-t ：查看打包文件的内容含有哪些文件名<br>-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中<br>-j ：通过bzip2的支持进行压缩/解压缩<br>-z ：通过gzip的支持进行压缩/解压缩<br>-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来<br>-f filename ：filename为要处理的文件<br>-C dir ：指定压缩/解压缩的目录dir  </p><p>上面的解说可以已经让你晕过去了，但是通常我们只需要记住下面三条命令即可：</p><p>[html] view plain copy<br>压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称<br>查询：tar -jtv -f filename.tar.bz2<br>解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录<br>注：文件名并不定要以后缀tar.bz2结尾，这里主要是为了说明使用的压缩程序为bzip2</p><h3 id="13、cat命令"><a href="#13、cat命令" class="headerlink" title="13、cat命令"></a>13、cat命令</h3><p>该命令用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用，从而可以一页页地查看数据。例如：</p><p>[html] view plain copy<br>cat text | less # 查看text文件中的内容  </p><h1 id="注：这条命令也可以使用less-text来代替"><a href="#注：这条命令也可以使用less-text来代替" class="headerlink" title="注：这条命令也可以使用less text来代替"></a>注：这条命令也可以使用less text来代替</h1><h3 id="14、chgrp命令"><a href="#14、chgrp命令" class="headerlink" title="14、chgrp命令"></a>14、chgrp命令</h3><p>该命令用于改变文件所属用户组，它的使用非常简单，它的基本用法如下：</p><p>[html] view plain copy<br>chgrp [-R] dirname/filename<br>-R ：进行递归的持续对所有文件和子目录更改  </p><h1 id="例如：-5"><a href="#例如：-5" class="headerlink" title="例如："></a>例如：</h1><p>chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users  </p><h3 id="15、chown命令"><a href="#15、chown命令" class="headerlink" title="15、chown命令"></a>15、chown命令</h3><p>该命令用于改变文件的所有者，与chgrp命令的使用方法相同，只是修改的文件属性不同，不再详述。</p><h3 id="16、chmod命令"><a href="#16、chmod命令" class="headerlink" title="16、chmod命令"></a>16、chmod命令</h3><p>该命令用于改变文件的权限，一般的用法如下：</p><p>[html] view plain copy<br>chmod [-R] xyz 文件或目录<br>-R：进行递归的持续更改，即连同子目录下的所有文件都会更改<br>同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改。</p><p>[html] view plain copy</p><h1 id="例如：-6"><a href="#例如：-6" class="headerlink" title="例如："></a>例如：</h1><pre><code>chmod 0755 file # 把file的文件权限改变为-rxwr-xr-x  chmod g+w file # 向file的文件权限中加入用户组可写权限  </code></pre><h3 id="18、vim命令"><a href="#18、vim命令" class="headerlink" title="18、vim命令"></a>18、vim命令</h3><p>该命令主要用于文本编辑，它接一个或多个文件名作为参数，如果文件存在就打开，如果文件不存在就以该文件名创建一个文件。vim是一个非常好用的文本编辑器，它里面有很多非常好用的命令，在这里不再多说。你可以从这里下载vim常用操作的详细说明。</p><h3 id="19、gcc命令"><a href="#19、gcc命令" class="headerlink" title="19、gcc命令"></a>19、gcc命令</h3><p>对于一个用Linux开发C程序的人来说，这个命令就非常重要了，它用于把C语言的源程序文件，编译成可执行程序，由于g++的很多参数跟它非常相似，所以这里只介绍gcc的参数，它的常用参数如下：</p><p>[html] view plain copy<br>-o ：output之意，用于指定生成一个可执行文件的文件名<br>-c ：用于把源文件生成目标文件（.o)，并阻止编译器创建一个完整的程序<br>-I ：增加编译时搜索头文件的路径<br>-L ：增加编译时搜索静态连接库的路径<br>-S ：把源文件生成汇编代码文件<br>-lm：表示标准库的目录中名为libm.a的函数库<br>-lpthread ：连接NPTL实现的线程库<br>-std= ：用于指定把使用的C语言的版本  </p><h1 id="例如：-7"><a href="#例如：-7" class="headerlink" title="例如："></a>例如：</h1><h1 id="把源文件test-c按照c99标准编译成可执行程序test"><a href="#把源文件test-c按照c99标准编译成可执行程序test" class="headerlink" title="把源文件test.c按照c99标准编译成可执行程序test"></a>把源文件test.c按照c99标准编译成可执行程序test</h1><p>gcc -o test test.c -lm -std=c99  </p><p>#把源文件test.c转换为相应的汇编程序源文件test.s<br>gcc -S test.c  </p><h3 id="20、time命令"><a href="#20、time命令" class="headerlink" title="20、time命令"></a>20、time命令</h3><p>该命令用于测算一个命令（即程序）的执行时间。它的使用非常简单，就像平时输入命令一样，不过在命令的前面加入一个time即可，例如：</p><p>[html] view plain copy<br>time ./process<br>time ps aux  </p><p>在程序或命令运行结束后，在最后输出了三个时间，它们分别是：</p><p>user：用户CPU时间，命令执行完成花费的用户CPU时间，即命令在用户态中执行时间总和；</p><p>system：系统CPU时间，命令执行完成花费的系统CPU时间，即命令在核心态中执行时间总和；</p><p>real：实际时间，从command命令行开始执行到运行终止的消逝时间；</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipes 添加Tomcat服务器方法</title>
      <link href="/2018/06/10/eclipes-tian-jia-tomcat-fu-wu-qi-fang-fa/"/>
      <url>/2018/06/10/eclipes-tian-jia-tomcat-fu-wu-qi-fang-fa/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进制转换小心得</title>
      <link href="/2018/05/07/2018-02-26-jin-zhi-zhuan-huan-xiao-xin-de/"/>
      <url>/2018/05/07/2018-02-26-jin-zhi-zhuan-huan-xiao-xin-de/</url>
      
        <content type="html"><![CDATA[<h3>之前也搞不太明白 是在计算机网络的课上利用ip和子网掩吗码算出网段号期间学会的</h3><h3>二进制转十进制</h3>    二进制转十进制  从最后一位开始算，依次列为第0、1、2...位  第n位的数（0或1）乘以2的n次方  得到的结果相加就是答案  例如:01101011.转十进制:  第0位:1乘2的0次方=1  1乘2的1次方=2  0乘2的2次方＝0  1乘2的3次方＝8  0乘2的4次方＝0  1乘2的5次方＝32  1乘2的6次方＝64  0乘2的7次方＝0  然后：1＋2＋0  ＋8＋0＋32＋64＋0＝107．  二进制01101011＝十进制107．<h3>十进制转二进制</h3>用2辗转相除至结果为1  将余数和最后的1从下向上倒序写 就是结果  例如302  302/2 = 151 余0  151/2 = 75 余1  75/2 = 37 余1  37/2 = 18 余1  18/2 = 9 余0  9/2 = 4 余1  4/2 = 2 余0  2/2 = 1 余0  故二进制为100101110]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的遍历</title>
      <link href="/2018/04/03/2018-04-03-tu-de-bian-li/"/>
      <url>/2018/04/03/2018-04-03-tu-de-bian-li/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念　"></a>概念　</h3><p>　　简单图(simple graph):就是由一些顶点(V,vertice) 和 连接这些顶点的一些边(E,edge)所组成的结构,并且每对顶点之间只能存在一条边.所以通常会用G = (V,E)来表示一个简单图.简单图也被称为无向图(undirected graph).</p><p>　　说到无向图就一定有有向图(directed graph),有向图同样也用G = (V,E)来表示,都明白两种图的区别是什么,就不多说了.不过在这里说一些表示边时候的区别:</p><p>　　简单图的边使用{Vi,Vj}的方式表示,表示连接顶点i与顶点j的边.因为是简单图,所以有:</p><p>　　　{Vi,Vj} = {Vj,Vi,}<br>　　有向图的边使用(Vi,Vj)的方式表示.意思是当前边的方向是从顶点i到顶点j,所以很明显有:</p><p>　　     (Vi,Vj) ≠ (Vj,Vi)   </p><h3 id="2-图的表示"><a href="#2-图的表示" class="headerlink" title="2.图的表示"></a>2.图的表示</h3><p>　　有很多方法可以表示一个图,不过思想上大致都一样.比如下面一个图(本文之后都会用这个图来作为例子):</p><p>图1</p><p>　　自己画的,或许丑了点:)</p><p>　　先看使用邻接表(adjacency list)来表示该图:</p><p>V0    V1   V2　<br>V1    V0   V3　<br>V2    V0   V3   V4<br>V3    V1   V2   V5   V6<br>V4    V2   V7<br>V5    V3   V6<br>V6    V3   V5<br>V7    V4<br>　　仔细观察就会发现，邻接表是在首列按顺序（正序倒序都可）列出所有顶点，然后第二行列出与顶点相邻的所有顶点，例如第一行，图中与V0相邻的顶点有V1与V2.所以第二列的内容便是 V1 与 V2.</p><p>　　另一种表示方法是使用邻接矩阵（adjacency matrix），思想与邻接表大致相同，不同的是邻接表是将与某一顶点相邻的顶点们列出，而邻接矩阵是将他们标注出。顾名思义就是使用矩阵表示，如在本例中，一共有8个顶点，所以此时邻接矩阵的大小就为8*8。如下：</p><pre><code> V0    V1    V2    V3    V4    V5    V6    V7</code></pre><p>V0    oo    1    1    oo    oo    oo    oo    oo<br>V1    oo    oo    oo    1    oo    oo    oo    oo<br>V2    oo    oo    oo    1    1    oo    oo    oo<br>V3    oo    1    1    oo    oo    1    1    oo<br>V4    oo    oo    1    oo    oo    oo    oo    1<br>V5    oo    oo    oo    1    oo    oo    1    oo<br>V6    oo    oo    oo    1    oo    1    oo    oo<br>V7    oo    oo    oo    oo    1    oo    oo    oo<br>　　观察可以发现，如果顶点i与顶点j之间存在边，就将矩阵的aij项设为1，其他情况就设为无穷大(oo)。公式就是：</p><p>　　　　　　　　　　　　　　　　　　　　　　｛   1    边(Vi ,Vj)存在 </p><p>　　　　　　　　　　　　　　　　　　　　aij = {</p><p>　　　　　　　　　　　　　　　　　　　　　　｛   无穷大    其他情况</p><p>　　如果对于有向图,此公式就得改为:</p><p>　　　　　　　　　　　　　　　　　　　　　　｛   1    边{Vi ,Vj}存在 </p><p>　　　　　　　　　　　　　　　　　　　　aij = {</p><p>　　　　　　　　　　　　　　　　　　　　　　｛   无穷大    其他情况</p><p>　　</p><p>　　对于使用哪种表示法，这要取决与你所要处理的问题，如果你仅仅只是处理与某一顶点邻接的顶点，例如遍历，很明显使用表比使用矩阵所要步数要少很多。当你需要对图进行插入或者删除顶点的操作，就应该使用邻接矩阵，你只需要将矩阵上的数从0变为1，或者从1变为0即可。而使用邻接表，你还得要对表进行维护。</p><p>　　本例就选用邻接矩阵来表示图1,用二维数组就能直接实现,无穷大被换成了名为oo的变量.如下:</p><p> 1         int oo = Integer.MAX_VALUE;<br> 2         int[][] racs1 = new int[][]{<br> 3                 {oo, 1, 1,oo,oo,oo,oo,oo},<br> 4                 { 1,oo,oo, 1,oo,oo,oo,oo},<br> 5                 { 1,oo,oo, 1, 1,oo,oo,oo},<br> 6                 {oo, 1, 1,oo,oo, 1, 1,oo},<br> 7                 {oo,oo, 1,oo,oo,oo,oo, 1},<br> 8                 {oo,oo,oo, 1,oo,oo, 1,oo},<br> 9                 {oo,oo,oo, 1,oo, 1,oo,oo},<br>10                 {oo,oo,oo,oo, 1,oo,oo,oo},<br>11         };</p><p>  　　</p><p>　　除此之外,这里还设定义了一个数组,用于为每个顶点添加一些信息.也就是各个顶点的名字.如果对与具体的问题,例如每个顶点代表地图上的一个城市,可使用像”北京”,”上海”城市名.当然可以很据特定情况将顶点的相关内容封装一下.</p><p>1         String[] verticeInfos1 = new String[] {<br>2                 “V0”,”V1”,”V2”,”V3”,”V4”,”V5”,”V6”,”V7”<br>3         };</p><p>　　另:有一种图中有孤立顶点的情况，假设上面的图中有还有一个顶点V8，但它不与任何其他顶点相邻，则该怎么用表或者矩阵来表示那？就当留给大家的一个小问题。</p><h3 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3.图的遍历"></a>3.图的遍历</h3><p>　　3.1 先写一个名为Graph的类.用这个类来封装图的相关字段和遍历方法.先看类的字段与构造方法:</p><p> 1 /** 2  * 使用邻接矩阵实现图</p><p><br> 3  * 深度优先遍历与广度优先遍历</p><p><br> 4  * 求最短路径:</p><p><br> 5  *      1. Dijkstra 算法 </p><p><br> 6  *      2. Ford 算法 </p><p><br> 7  *      3. 通用型的纠正标记算法</p><p><br> 8  * Created by Henvealf on 16-5-22.<br> 9  */<br>10 public class Graph<t> {<br>11     private int[][] racs;       //邻接矩阵<br>12     private T[] verticeInfo;   //各个点所携带的信息.<br>13<br>14     private int verticeNum;             //节点的数目,<br>15     private int[] visitedCount;         //记录访问<br>16     private int[] currDist;             //最短路径算法中用来记录每个节点的当前路径长度.<br>17<br>18     public Graph(int[][] racs, T[] verticeInfo){<br>19         if(racs.length != racs[0].length){<br>20             throw new IllegalArgumentException(“racs is not a adjacency matrix!”);<br>21         }<br>22         if(racs.length != verticeInfo.length ){<br>23             throw new IllegalArgumentException (“Argument of 2 verticeInfo’s length is error!”);<br>24         }<br>25         this.racs = racs;<br>26         this.verticeInfo = verticeInfo;<br>27         verticeNum = racs.length;<br>28         visitedCount = new int[verticeNum];<br>29     }<br>30     //…..其他方法<br>31 }</t></p><p>　　这里使用了模板来模板化 verticeInfos.</p><p>　　还要说明的便是数组 int[] visitedCount; 其作用是为了标记图中的顶点是否被访问过. visitedCount[i] == 0 就说明顶点 i 还未被访问过,所以在进行遍历操作前需要初始化该数组全为0.方法如下:　　</p><p>1     /**2      * 将记录访问的数组初始化为0<br>3      */<br>4     private void initVisitedCount(){<br>5         for(int i = 0; i &lt; visitedCount.length; i ++){　　<br>6             visitedCount[i] = 0;<br>7         }<br>8     }</p><p>　　3.2 图的遍历和树的遍历类似,分为深度优先遍历与广度优先遍历.</p><p>　　深度优先遍历,简单说就是先沿着一条路线最靠左或最靠右的路线往下走,并把路过的顶点标记为已访问.一直走到无路可走,或者下一站的顶点都被已经访问过了,就顺着刚才走过的路往回看(回溯),当发现回溯中的某一顶点还有其他未被访问过的分支的时候,就选择这个分支继续,重复上面的过程继续遍历.直到回溯到了遍历的出发点,就结束遍历.但如果检查发现图中还存在未被访问过的顶点,就说明图中还存在孤立与本图的分图.此时则任意选择一个未被访问过的顶点继续访问.  最后当图中所有的顶点都被访问过的时候,就说明遍历完成.　</p><p>　　所以这里需要一个方法,用来判断图中顶点的访问情况:</p><p> 1     /** 2      * 寻找没有被访问过的顶点.<br> 3      * @return &gt; 0 即为还未被访问过的顶点.   -1 说明所有的节点都被访问过了.<br> 4      */<br> 5     private int findNotVisited(){<br> 6         for(int i = 0; i &lt; noteNum; i ++){<br> 7             if(visitedCount[i] == 0){<br> 8                 return i;<br> 9             }<br>10         }<br>11         return -1;<br>12     }</p><p>　　要寻找与顶点的相邻节点时,我们可以发现简单图的邻接矩阵以对角线对称,所以寻找相邻顶点的时候只需要遍历一半就可以,大大的提高了遍历的效率,不过对于有向图就需要遍历全图.这里只讨论简单图,有向图自行修改区分便可,这里是遍历全图:</p><p> 1     /** 2      * 深度遍历的递归<br> 3      * @param begin  从第几个节点开始遍历<br> 4      <em>/ 5     public void DFS(int begin, Queue<t> edges){<br> 6         visitedCount[begin] = 1;                         //标记begin为已访问<br> 7         edges.offer(verticeInfo[begin]);                 //加入记录队列<br> 8         for(int a = 0; a &lt; verticeNum; a++){             //遍历相邻的点<br> 9             if((racs[begin][a] != Integer.MAX_VALUE)&amp;&amp; visitedCount[a] == 0){   //相邻的点未被访问过<br>10                 DFS(a,edges);<br>11             }<br>12         }<br>13     }<br>14<br>15     /*</t></em><br>16      * 开始深度优先遍历<br>17      * @return  返回保持有遍历之后的顺序的队列<br>18      */<br>19     public Queue<t> depthFirstSearch(){<br>20         initVisitedCount();         //将记录访问次序的数组初始化为0<br>21         Queue<t> edges = new LinkedList&lt;&gt;();    //用于存储遍历过的点,用于输出<br>22         int begin = -1;<br>23         while((begin = findNotVisited()) != -1){        //不等于-1说明还有未访问过的点<br>24             DFS(begin,edges);<br>25         }<br>26         return edges;<br>27     }</t></t></p><p> 　　广度优先遍历.与树的广度优先遍历相似,就是逐层遍历.代码如下:</p><p> 1     /** 2      * 广度优先遍历<br> 3      * @return  返回保持有遍历之后的顺序的队列<br> 4      */<br> 5     public Queue<t> breadthFirstSearch(){<br> 6         initVisitedCount();                          //将记录访问次序的数组初始化为0<br> 7         Queue<integer> tallyQueue = new LinkedList&lt;&gt;();             //初始化队列<br> 8         Queue<t> edges = new LinkedList&lt;&gt;();    //用于存储遍历过的点,用于输出<br> 9         int nowVertice = -1;                         //当前所在的点<br>10         while((nowVertice = findNotVisited()) != -1){   //寻找还未被访过问的点<br>11             visitedCount[nowVertice] = 1;             //设置访问标记<br>12             edges.offer(verticeInfo[nowVertice]);<br>13             tallyQueue.offer(nowVertice);               //将当前孤立部分一个顶点加入记录队列中<br>14             while(!tallyQueue.isEmpty()){                           //只要队列不为空<br>15                 nowVertice = tallyQueue.poll();                     //取出队首的节点<br>16                 for(int a = 0; a &lt; verticeNum; a++){     //遍历所有和nowVertice相邻的节点<br>17                     if((racs[nowVertice][a] != Integer.MAX_VALUE) &amp;&amp; visitedCount[a] == 0) {                      //没有访问过<br>18                         visitedCount[a] = 1;                        //记为标记过<br>19                         tallyQueue.offer(a);                        //加入队列,上面会继续取出.来遍历<br>20                         edges.offer(verticeInfo[a]);                      //记录<br>21                     }<br>22                 }<br>23             }<br>24         }<br>25         return edges;<br>26     }</t></integer></t></p><p>　　这里需要两个队列,一个队列用于存储遍历过程,另一个用于保存第n层被遍历的顺序,等到遍历第n+1层的时候,取出的顶点就是按照上层的顺序来排列,也就能按照上层的顺序来继续遍历.</p><p>下面是Graph完整代码:</p><p>  1 package com.henvealf.datastructures.graph.arcs;<br>  2<br>  3 import java.util.<em>;  4<br>  5 /*</em><br>  6  * 使用邻接矩阵实现图</p><p><br>  7  * 深度优先遍历与广度优先遍历</p><p><br>  8  * 求最短路径:</p><p><br>  9  *      1. Dijkstra 算法 </p><p><br> 10  *      2. Ford 算法 </p><p><br> 11  *      3. 通用型的纠正标记算法</p><p><br> 12  * Created by Henvealf on 16-5-22.<br> 13  <em>/ 14 public class Graph<t> {<br> 15     private int[][] racs;       //邻接矩阵<br> 16     private T[] verticeInfo;   //各个点所携带的信息.<br> 17<br> 18     private int verticeNum;             //节点的数目,<br> 19     private int[] visitedCount;         //记录访问<br> 20     private int[] currDist;             //最短路径算法中用来记录每个节点的当前路径长度.<br> 21<br> 22     public Graph(int[][] racs, T[] verticeInfo){<br> 23         if(racs.length != racs[0].length){<br> 24             throw new IllegalArgumentException(“racs is not a adjacency matrix!”);<br> 25         }<br> 26         if(racs.length != verticeInfo.length ){<br> 27             throw new IllegalArgumentException (“Argument of 2 verticeInfo’s length is error!”);<br> 28         }<br> 29         this.racs = racs;<br> 30         this.verticeInfo = verticeInfo;<br> 31         verticeNum = racs.length;<br> 32         visitedCount = new int[verticeNum];<br> 33     }<br> 34<br> 35     /*</t></em><br> 36      * 深度遍历的递归<br> 37      * @param begin  从第几个节点开始遍历<br> 38      <em>/ 39     public void DFS(int begin, Queue<t> edges){<br> 40         visitedCount[begin] = 1;                         //标记begin为已访问<br> 41         edges.offer(verticeInfo[begin]);                 //加入记录队列<br> 42         for(int a = 0; a &lt; verticeNum; a++){             //遍历相邻的点<br> 43             if((racs[begin][a] != Integer.MAX_VALUE)&amp;&amp; visitedCount[a] == 0){   //相邻的点未被访问过<br> 44                 DFS(a,edges);<br> 45             }<br> 46         }<br> 47     }<br> 48<br> 49     /*</t></em><br> 50      * 开始深度优先遍历<br> 51      * @return  返回保持有遍历之后的顺序的队列<br> 52      <em>/ 53     public Queue<t> depthFirstSearch(){<br> 54         initVisitedCount();         //将记录访问次序的数组初始化为0<br> 55         Queue<t> edges = new LinkedList&lt;&gt;();    //用于存储遍历过的点,用于输出<br> 56         int begin = -1;<br> 57         while((begin = findNotVisited()) != -1){        //不等于-1说明还有未访问过的点<br> 58             DFS(begin,edges);<br> 59         }<br> 60         return edges;<br> 61     }<br> 62<br> 63     /*</t></t></em><br> 64      * 广度优先遍历<br> 65      * @return  返回保持有遍历之后的顺序的队列<br> 66      <em>/ 67     public Queue<t> breadthFirstSearch(){<br> 68         initVisitedCount();                          //将记录访问次序的数组初始化为0<br> 69         Queue<integer> tallyQueue = new LinkedList&lt;&gt;();             //初始化队列<br> 70         Queue<t> edges = new LinkedList&lt;&gt;();    //用于存储遍历过的点,用于输出<br> 71         int nowVertice = -1;                         //当前所在的点<br> 72         while((nowVertice = findNotVisited()) != -1){   //寻找还未被访过问的点<br> 73             visitedCount[nowVertice] = 1;             //设置访问标记<br> 74             edges.offer(verticeInfo[nowVertice]);<br> 75             tallyQueue.offer(nowVertice);               //将当前孤立部分一个顶点加入记录队列中<br> 76             while(!tallyQueue.isEmpty()){                           //只要队列不为空<br> 77                 nowVertice = tallyQueue.poll();                     //取出队首的节点<br> 78                 for(int a = 0; a &lt; verticeNum; a++){     //遍历所有和nowVertice相邻的节点<br> 79                     if((racs[nowVertice][a] != Integer.MAX_VALUE) &amp;&amp; visitedCount[a] == 0) {                      //没有访问过<br> 80                         visitedCount[a] = 1;                        //记为标记过<br> 81                         tallyQueue.offer(a);                        //加入队列,上面会继续取出.来遍历<br> 82                         edges.offer(verticeInfo[a]);                      //记录<br> 83                     }<br> 84                 }<br> 85             }<br> 86         }<br> 87         return edges;<br> 88     }<br> 89<br> 90     /*</t></integer></t></em><br> 91      * 寻找没有被访问过的顶点.<br> 92      * @return &gt; 0 即为还未被访问过的顶点.   -1 说明所有的节点都被访问过了.<br> 93      <em>/ 94     private int findNotVisited(){<br> 95         for(int i = 0; i &lt; verticeNum; i ++){<br> 96             if(visitedCount[i] == 0){<br> 97                 return i;<br> 98             }<br> 99         }<br>100         return -1;<br>101     }<br>102<br>103     /*</em><br>104      * 将记录访问的数组初始化为0<br>105      */<br>106     private void initVisitedCount(){<br>107         for(int i = 0; i &lt; visitedCount.length; i ++){<br>108             visitedCount[i] = 0;<br>109         }<br>110     }<br>111 }</p><p>下面测试类:</p><p>package com.henvealf.datastructures.graph.arcs;</p><p>import java.util.Queue;</p><p>/**</p><ul><li><p>图的测试类</p></li><li><p>Created by Henvealf on 16-5-22.</p></li><li><p>/public class Main {</p><p>  public static void main(String[] args) {</p><pre><code>  int[][] racs = new int[][]{          {0,1,0,1,0,},          {1,0,1,0,1,},          {0,1,0,1,1,},          {1,0,1,0,0,},          {0,1,1,0,0,},  };  int oo = Integer.MAX_VALUE;  int[][] racs1 = new int[][]{          {oo, 1, 1,oo,oo,oo,oo,oo},          { 1,oo,oo, 1,oo,oo,oo,oo},          { 1,oo,oo, 1, 1,oo,oo,oo},          {oo, 1, 1,oo,oo, 1, 1,oo},          {oo,oo, 1,oo,oo,oo,oo, 1},          {oo,oo,oo, 1,oo,oo, 1,oo},          {oo,oo,oo, 1,oo, 1,oo,oo},          {oo,oo,oo,oo, 1,oo,oo,oo},  };  String[] verticeInfos1 = new String[] {          &quot;V0&quot;,&quot;V1&quot;,&quot;V2&quot;,&quot;V3&quot;,&quot;V4&quot;,&quot;V5&quot;,&quot;V6&quot;,&quot;V7&quot;  };  Graph&lt;String&gt; graph = new Graph&lt;&gt;(racs2,verticeInfos2);  Queue&lt;String&gt; dr = graph.depthFirstSearch();  Queue&lt;String&gt; br = graph.breadthFirstSearch();  System.out.println(&quot;--遍历&quot;);  System.out.println(&quot;----深度优先结果: &quot; + dr);  System.out.println(&quot;----广度优先结果: &quot; + br);</code></pre><p>}</p></li></ul><p><br>引用自CSDN：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
